\chapter{Implementación}

\section{Elección de herramientas} \label{sec:tools}
Una vez realizada la elección de modelos en el apartado anterior \ref{ch:design}, la
elección de las herramientas es un proceso mucho más sencillo, ya que hemos establecido
los criterios que nos ayudarán a escoger aquella que se adapte mejor a las necesidades
de nuestro proyecto (en este caso de la aplicación web).

\subsection{\textit{Framework} para desarrollo web}

    \subsubsection{Ruby on Rails}
    \textbf{Ruby on Rails} (también conocido como Rails) \cite{ruby-on-rails} es un
    \textit{framework} para la creación de aplicaciones web escrito en Ruby. Sigue una
    arquitectura \textit{Model-View-Controller} y diseño RESTfull\footnote{Un servicio
    es RESTfull cuando cumple con la \textbf{arquitectura REST}, es decir, facilita el
    acceso a recursos remotos y, además define las operaciones típicas por medio de URIs
    (listar, crear, leer, actualizar y borrar).}. Está diseñado para facilitar la
    programación web al hacer una estimación de los componentes principales que se
    necesitan para comenzar.\\

    Este \textit{software} asume que hay una mejor forma de hacer las cosas y está diseñado
    para ello, por lo que es un código muy optimizado y hecho para aumentar la productividad
    si se hace el desarrollo de la forma <<The Rails Way>>.

    \subsubsection{Django}
    \textbf{Django} \cite{django} es el \textit{framework} para Python más usado, está
    enfocado a sitios basados en bases de datos. Permite un desarrollo \textit{software}
    muy rápido y limpio. Tiene una arquitectura MTV (\textit{Model-Template-View}), donde el
    \textit{View} sería el equivalente a \textit{Controller} en MVC. El esquema básico de este
    patrón es el siguiente:

        \begin{figure}[H]
            \centering
            \includegraphics[scale=0.22]{imagenes/mvt.png}
            \caption[Patrón Modelo-Plantilla-Vista]{Patrón Modelo-Plantilla-Vista. Fuente \cite{mvt}}
            \label{fig:mvt}
        \end{figure}

    Como vemos, el flujo de comunicación entre estos tres bloques sería el siguiente:
        
       \begin{enumerate}
           \item El usuario interacciona con la interfaz al solicitar una URL.
           \item El \textit{framework} de Django, a través de su archivo urls.py, se encarga
           de decidir qué \textbf{vista} se debe mostrar.
           \item Si dicha vista obtiene datos de la base de datos, esta se comunica con el 
           \textbf{modelo}.
           \item Finalmente, se devuelve la \textbf{plantilla} con los datos de la base de
           datos si fuera necesario.
       \end{enumerate}

    Al igual que el anterior \textit{framework} mencionado, Django ha sido diseñado por
    programadores experimentados, y se encarga de las partes más complejas del desarrollo
    web, permitiendo que el programador se centre en escribir la aplicación sin necesidad
    de preocuparse por otras cuestiones.

    \subsubsection{Laravel}
    \textbf{Laravel} \cite{laravel} es el mejor \textit{framework} de PHP para desarrollar
    aplicaciones y servicios web con PHP5, PHP7 y PHP8. Al igual que Ruby on Rails, sigue
    una arquitectura MVC, por lo que es sencillo relacionar los distintas componentes de la
    aplicación.\\

    Es un \textit{framework} moderno que ofrece muchas utilidades a los desarrolladores y
    permiten un desarrollo ágil de las aplicaciones web. Además, pone mucho interés en la
    calidad del código, el mantenimiento y la escalabilidad.

    \subsubsection{Angular}
    \textbf{Angular} \cite{angular} es un \textit{framework} desarrollado en TypeScript para
    el desarrollo de aplicaciones web. Está mantenido por Google, utilizado para crear y
    mantener aplicaciones SPA (Single Page Application), es decir, páginas web que
    interaccionan con el usuario dinámicamente sobreescribiendo la página con información
    nueva.\\

    Al contrario que los \textit{frameworks} anteriormente mencionados, Angular no usa un
    modelo MVC o MVT, sino que permite el desarrollo del \textit{frontend} y el \textit{backend}
    de forma totalmente independiente.

\subsection{\textit{Framework} CSS}

    \subsubsection{Tailwind CSS}
    \textbf{Tailwind CSS} \cite{tailwind-css} es un \textit{framework} CSS que funciona
    escaneando los archivos HTML, componentes JavaScript y otros \textit{templates} generando los
    correspondientes estilos y escribiéndolos en un archivo CSS estático. No tiene muchos
    componentes, sino clases de utilidad que pueden aplicarse directamente sobre el código
    HTML del proyecto. Además de esto, permite una gran optimización del peso del código
    CSS mediante unos flujos de desarrollo.
        
    \subsubsection{Bootstrap}
    \textbf{Bootstrap} \cite{bootstrap} es uno de los \textit{frameworks} más populares y
    usados para el desarrollo de páginas web. Fue desarrollado por Twitter en 2010 para
    uso de la compañía pero más tarde pasó a ser código abierto. Este \textit{framework}
    combina CSS y JavaScript. Entre sus características fundamentales podemos encontrar:
    
    % \begin{list}{\textbullet}{ 
        %     \addtolength{\labelsep}{1mm}    % Distancia hasta la etiqueta
        %     \addtolength{\itemsep}{-2mm}    % Separación entre items
        %     \setlength{\itemindent}{5mm}}   % Identación de los items
        % \end{list}
        
        \begin{itemize}
            \item \textbf{\textit{Responsive design} (diseño adaptativo)}: adaptación
            automática a distintos dispositivos como móviles y tabletas.
            \item \textbf{\textit{Grid System} (sistema de rejilla)}: posicionamiento de
            elementos en la página.
            \item \textbf{\textit{Interface UI} (interfaz de usuario)}: incluye formularios,
            botones, menús, etc.
        \end{itemize}
        
        \subsubsection{Foundation}
        \textbf{Foundation} \cite{foundation} es el principal competidor de Bootstrap, es
        un \textit{framework} orientado al desarrollo de sitios web totalmente adaptativos
        bajo el enfoque \textit{mobile first}, que es una metodología de desarrollo donde
        se tienen en cuenta en primer lugar los dispositivos móviles. Esta metodología es
        totalmente contraria a la que usa Bootstrap, ya que en él se usa \textit{Responsive
        Web Design} y en este \textit{Mobile First Web Design}.\\
        
        Además de su metodología de desarrollo, posee ciertas características muy interesantes:
        
        \begin{itemize}
            \item \textbf{Fastclick}: eliminación del retraso al pulsar en dispositivos
            móviles.
            \item \textbf{Semántico}: todo es semántico, permitiendo tener un lenguaje de
            marcado limpio sin sacrificar su funcionalidad y velocidad.
            \item \textbf{Off Canvas}: creación de menús dinámicos
            \item \textbf{Customizable}: permite hacer diseños completamente personalizables,
            pudiendo eliminar elementos, definir el tamaño de las columnas, colores,
            fondos, etc.
        \end{itemize}

    \subsubsection{Materialize CSS}
    \textbf{Materialize CSS} \cite{materialize-css} sigue el principio \textit{Material Design},
    es decir, ofrece componentes ya listos para ser utilizados, por supuesto adaptativo.
    Además, integra comportamientos dinámicos mediante JavaScript y no necesita de Jquery para
    funcionar.\\

    Entre sus principales características se encuentran:
        
        \begin{itemize}
            \item Al igual que otros \textit{frameworks} mencionados, permite un diseño
            adaptativo.
            \item Permite crear menús laterales desplegables o abiertos según la resolución
            del dispositivo.
            \item Diseños utilizando la filosofía \textit{Material Design} (colecciones,
            tarjetas, barras de navegación, modales, toast, etc.).
            \item Añade utilidades como \textbf{Parallax} (técnica de diseño web en la que
            se crea un efecto de profundidad al hacer scroll)
        \end{itemize}

\subsection{Base de Datos}
Los distintos SGBD (Sistemas Gestores de Bases de Datos) que podemos encontrar son los
siguientes:

    \subsubsection{MySQL}
    \textbf{MySQL} \cite{mysql} es un sistema de gestión de bases de datos relacionales de
    código abierto, también conocido como RDBMS (\textit{Relational Database Management
    System}). Es una de las bases de datos más populares en la actualidad y usa un modelo
    cliente-servidor.
    

    \subsubsection{SQLite}
    \textbf{SQLite} \cite{sqlite} es un RDBMS de tamaño reducido (aproximadamente 275 kiB)
    que, a diferencia de otros RDBMS como mySQL, no usa un proceso cliente y un proceso
    servidor (modelo cliente-servidor). En este caso, funciona como un servidor
    propio independiente, haciendo uso de llamadas a subrutinas y funciones integradas en el
    propio código fuente que eliminan la necesidad de hacer consultas entre procesos
    separados.

    \subsubsection{PostgreSQL}
    \textbf{PostgreSQL} \cite{postgresql} es un sistema de gestión de base de datos relacional
    que está orientado a objetos, de código abierto y, además, gratuito. Este RDBMS posee tipos
    de datos avanzados y permite optimizar de forma considerable el rendimiento, este tipo de
    características, por lo general, solo se ofrecen en sistemas de bases de datos privativas.
    Además de las características anteriormente mencionadas, permite un control de grandes
    volúmenes de datos y tiene soporte completo para \textbf{ACID} (\textit{Atomicity,
    Consistency, Isolation, Durability}).

\subsection{Soluciones propuestas}
Como se ha mencionado anteriormente, en cualquier elección de herramientas se debe señalar
claramente las características que debe cumplir para así poder descartar con facilidad
entre las disintas alternativas.

    \subsubsection{Elección del \textit{Framework} de Desarrollo Web}
    El \textit{framework} de Desarrollo Web debe cumplir con una serie de \textbf{requisitos} para
    su aceptación:

        \begin{enumerate}
            \item Que siga un patrón Modelo-Vista-Controlador \ref{sec:mvc}.
            \item Que haga una deducción de los elementos principales de la aplicación,
            permitiendo centrarnos exclusivamente en el desarrollo de la misma.
            \item Que pueda permitir la configuración del mismo con distintas bases de
            datos.
            \item Que posea un sistema de gestión de usuarios (\textbf{autenticación}).
            \item Que el manejo de los modelos de la base de datos pueda abstraerse
            independientemente de la base de datos elegida mediante un
            \textbf{\textit{Object Relational Mapping}} (ORM).
            \item Que incluya una fácil creación de la API (\textit{Application Programming
            Interface} o interfaz de programación de aplicaciones) para la posible
            comunicación con la app Android.
        \end{enumerate}

    Tras tantear los distintos \textit{frameworks} para el desarrollo de aplicaciones web
    disponibles, se ha decidido utilizar Django, ya que está hecho en un lenguaje familiar
    para nosotros y, además, cumple todos los requisitos anteriormente mencionados.\\

    Dicho \textit{framework} permite hacer lo siguiente:
        
        \begin{itemize}
            \item Crear la aplicación sin tener que preocuparnos de elementos para que
            esta funcione.
            \item Configuración con distintas bases de datos, SQLite es la base de datos
            por defecto, pero además permite configurarlo para trabajar con mySQL y
            postgreSQL.
            \item Sistema de autenticación de usuarios, por lo que podremos gestionar el
            registro e inicio de sesión de los mismos.
            \item Contiene un ORM que permite el manejo de modelos de la base de datos
            abstrayendo la base de datos utilizada.
            \item A pesar de no venir incluido como tal, instalando la aplicación
            \textit{Django REST framework}, es posible realizar la configuración de la API
            de una forma relativamente sencilla.
            \item Tiene una documentación realmente buena, clara y sencilla.
        \end{itemize}
    
    Estas son las razones por las que se ha decidido elegir Django para el desarrollo de
    nuestra aplicación web.

    \subsubsection{Elección del \textit{Framework} CSS}
    Entre los requisitos que el \textit{framework} CSS debe cumplir están los siguientes:

        \begin{enumerate}
            \item Que permita un diseño adaptativo de la página web.
            \item Que siga la metodología \textit{Responsive Web Design}.
            \item Que sea fácil de usar.
            \item Que esté actualmente mantenido por la comunidad.
            \item Que posea una documentación simple y fácil de entender. 
        \end{enumerate}

    Siguiendo los requisitos de arriba, Foundation puede ser descartado, ya que no cumple el
    segundo requisito, ya que nuestra aplicación web principalmente va a estar diseñada para
    utilizarse en un ordenador (también podrá usarse en un \textit{smartphone}, pero no es
    la finalidad).\\

    Entre los tres \textit{frameworks} restantes, podría utilizarse cualquiera de ellos ya
    que cumplen con los requisitos, pero finalmente se ha decidido utilizar Bootstrap, ya que
    es probablemente el \textit{framework} más popular y sencillo de usar que hay, además
    de seguir siendo muy usado por la comunidad. 
    

    \subsubsection{Elección de la Base de Datos}
    Para la elección de la Base de Datos que utilizará el servidor web para almacenar toda
    la información de las excavaciones se tienen que cumplir los siguientes requisitos:

        \begin{enumerate}
            \item Que sea una base de datos relacional.
            \item Que sea \textit{open source} y gratuita.
            \item Que tenga soporte para la realización de transacciones seguras.
            \item Que haga un uso eficiente de los datos.
        \end{enumerate}

    Por cuestiones de escalabilidad, utilizar SQLite se puede descartar, puesto que posee un
    reducido número de tipos de datos y más bien está pensada para utilizarse en dispositivos
    con poca capacidad de almacenamiento.\\

    Ahora nos tocaría pensar en, ¿mySQL o postgreSQL? Realmente podría utilizarse cualquiera
    de las dos, pero postgreSQL ofrece algunas ventajas respecto a mySQL que merece la pena
    mencionar: 
    
        \begin{itemize}
            \item MySQL es propiedad de Oracle y podría pasar a ser un producto comercial
            (de pago), sin embargo, postgreSQL es \textbf{\textit{open source} 100\%}.
            \item PostgreSQL ofrece una mayor \textbf{integridad y fiabilidad} de los datos
            (principio ACID).
            \item Gracias a funciones de lectura y escritura en paralelo, postgreSQL ofrece
            una mayor \textbf{velocidad} frente a mySQL.
        \end{itemize}
    
    Por estas razones, finalmente se ha decidido usar postgreSQL como base de datos para
    nuestro servidor web.

\section{Desarrollo basado en \textit{sprints}} \label{sec:sprints}
Como mencionamos en el sub-apartado \ref{subsubsec:scrum}, se va a trabajar mediante
\textbf{\textit{sprints}}, concepto del marco de trabajo Scrum. Es por ello que el desarrollo del
\textit{software} se ha dividido en una serie de \textbf{hitos} (que en este caso serían
nuestros \textit{sprints}). Un hito, en el desarrollo de \textit{software}, simboliza un
logro, un aspecto del proyecto que se está cumpliendo conforme se planificó al comienzo del
mismo, por tanto, estos son los mejores indicadores del progreso del proyecto para alcanzar
los objetivos finales.\\

A cada uno de estos \textit{sprints} se le irán asociando \textbf{\textit{issues}} (tareas)
que se deben realizar para alcanzar el objetivo del mismo. Dichas tareas pueden ser aspectos
a mejorar del \textit{software}, errores que se han encontrado, tareas referentes a
documentación, etc.\\

Los hitos (\textbf{\textit{milestones}}) del proyecto son los siguientes:
\begin{enumerate}
    \item \textbf{\href{https://github.com/alexespana/TFG/milestone/1}{[M1].
    \textit{Website creation} (Creación del sitio web)}}: creación de la estructura
    principal de la aplicación web, con las principales páginas y funcionalidades. Esta
    parte será desarrollada en un entorno de desarrollo (servidor de desarrollo).
    \item \textbf{\href{https://github.com/alexespana/TFG/milestone/8}{[M2].
    \textit{Database creation} (Creación de la Base de Datos)}}: creación de las principales
    tablas para modelar el problema, junto con los correspondientes formularios para la
    recogida de datos en la aplicación web.
    \item \textbf{\href{https://github.com/alexespana/TFG/milestone/2}{[M3].
    \textit{Authentication} (Autenticación)}}: gestión de usuarios del sitio web,
    \textit{signup, signout, login, logout}, cambiar contraseña e información de contacto
    para cada usuario así como \textit{third party} (social) \textit{account authentication}. 
    \item \textbf{\href{https://github.com/alexespana/TFG/milestone/3}{[M4].
    \textit{Test behavior} (Testear comportamiento)}}: realización de tests para comprobar
    el comportamiento de la aplicación.
    \item \textbf{\href{https://github.com/alexespana/TFG/milestone/4}{[M5].
    \textit{Continuous integration} (Integración Continua)}}: el \textit{software}
    desarrollado debe integrarse con el posible \textit{software} ya existente en el sitio
    web, asegurando el correcto funcionaminto de ambos.
    \item \textbf{\href{https://github.com/alexespana/TFG/milestone/6}{[M6].
    \textit{API REST}}}: el diseño y posterior implementación de la API REST que permita
    gestionar los recursos con los que trabaja la aplicación.
    \item \textbf{\href{https://github.com/alexespana/TFG/milestone/5}{[M7].
    \textit{Log system} (Sistema de \textit{Log})}}: los eventos más importantes que
    ocurren en la aplicación deben ser grabados a través del uso de un servicio de
    \textit{log}. Es conveniente capturar errores en un nivel superior de abstracción,
    evitando modificar código ya hecho.
    \item \textbf{\href{https://github.com/alexespana/TFG/milestone/7}{[M8].
    \textit{Deployment} (Despliegue)}}: el despliegue de la aplicación web en la nube debe
    realizarse utilizando un dominio público y un WSGI (\textit{Web Server Gateway Interface}).
\end{enumerate}

Si desea tener una vista más general de los \textit{milestones}, \textit{issues},
\textit{commits}, \textit{branches}, etc. del proyecto puede visitar los siguientes enlaces:

\begin{itemize}
    \item \textbf{\href{https://github.com/alexespana/TFG/milestones}{\textit{Milestones} (Hitos)}}
    \item \textbf{\href{https://github.com/alexespana/TFG/issues}{\textit{Issues} (Tareas)}}
    \item \textbf{\href{https://github.com/alexespana/TFG/branches}{\textit{Branches} (Ramas)}}
    \item \textbf{\href{https://github.com/alexespana/TFG/pulls}{\textit{Pull requests} (Solicitudes
    de cambio)}}
\end{itemize}


\subsection{Creación del sitio web}
Para realizar la implementación de las distintas plantillas de la aplicación se ha hecho
uso del sistema propio de plantillas de Django, llamado \textbf{Django template language},
que es muy parecido a JinJa2 y que está completamente implementado en los \textit{backends}
que incluye de serie.\\

A la hora de pensar en un diseño para la aplicación web se ha optado por un diseño
minimalista, que permita diferenciar fácilmente las distintas partes de la aplicación
junto con sus funcionalidades.\\

Es importante mencionar que todas las plantillas del proyecto hacen uso de una plantilla
base que contiene el navegador de la página y el pie de página, por lo que dicha plantilla base
sería tal que así:\\

    \begin{figure}[H]
        \centering
        \includegraphics[scale=0.24]{imagenes/base.png}
        \caption{Plantilla base}
        \label{fig:base}
    \end{figure}

El resto de plantillas de este diseño son las que se describen en las secciones siguientes.

    \subsubsection{\textit{Home}}
    Esta es la página principal que se verá al entrar en la aplicación, prácticamente todo el
    diseño de esta tiene relación con un componente de Bootstrap llamado \textbf{Carousel},
    que nos permite construir una especie de \textit{sliders} en la vista con indicadores en
    la parte inferior. Además, cada uno de estos \textit{sliders} puede tener texto asociado
    e imágenes de fondo, por lo que podemos ir cambiando el fondo completo de la página
    mediante el uso de JavaScript cada cierto tiempo predefinido. De esta forma, hacemos que
    entrar en la página sea una sensación agradable a primera vista. El \textbf{\textit{home}}
    quedaría así:
    
        \begin{figure}[H]
            \centering
            \includegraphics[scale=0.19]{imagenes/home.png}
            \caption[\textit{Home} de la página]{\textit{Home} de la página. Fuente \cite{maya}}
            \label{fig:home}
        \end{figure}

    \subsubsection{Listados}
    Esta parte de la vista corresponderá a distintas vistas que servirán para listar en forma
    de \textbf{tablas} las distintas excavaciones, estancias, hechos, unidades estratigráficas
    (sedimentarias y construidas), fotografías, materiales (sedimentarios y construidos) e
    inclusiones.\\

    Principalmente corresponderá a tablas donde además de la información propia
    de los registros se muestren las posibilidades de editar y eliminar dichos registros
    residentes en la base de datos que, como dijimos en la sección de análisis, va a ser
    PostgreSQL. Esta parte de la implementación se explicará en secciones posteriores.

    \newpage \subsubsection{Añadir}
    Esta sección de la página web corresponderá a las distintas vistas (formularios) que
    servirán para añadir los distintos componentes relacionados con las excavaciones:
    excavaciones, estancias, hechos, unidades estratigráficas (sedimentarias y construidas),
    fotografías, materiales (sedimentarios y construidos) e inclusiones.\\

    Cada uno de estos formularios pedirá al usuario los datos completos de cada elemento del
    que se trate, por supuesto, con la posibilidad de dejar algún campo en blanco, aunque
    no sería lo más normal, ya que en el servidor web la idea es rellenar de forma completa
    la información que se recopile en el registro de campo con la aplicación Android, además
    de añadir otra información.

    \subsubsection{Sobre la aplicación}
    En esta página de la web se hace alusión brevemente a cuál es la principal motivación
    de crear este proyecto y cuáles son las principales características que posee la
    aplicación: sincronización en tiempo real con la aplicación Android, fácil
    adición, edición y eliminación de información de los distintos elementos, generación
    de informes a partir de la información de la base de datos, etc.\\

    Dicha página quedaría de la siguiente forma:
        
        \begin{figure}[H]
            \centering
            \includegraphics[scale=0.23]{imagenes/about.png}
            \caption[Sobre la aplicación]{Sobre la aplicación. Fuente \cite{petra-ad-deir}}
            \label{fig:about}
        \end{figure}

    \newpage Como puede observarse, el contenido principal de la página está dividido en dos filas
    o \textbf{\textit{rows}} (normalmente se usa la terminología inglesa), la primera, que
    se corresponde con el título o \textbf{\textit{headline}} (común en muchas páginas) y la
    segunda, que está dividida en dos partes que usan 6 columnas de Bootstrap cada una,
    conteniendo la \textbf{motivación} y la \textbf{imagen} respectivamente.

    \subsubsection{Equipo}
    Esta página contiene información sobre los componentes que hemos hecho posible este
    proyecto, en este caso, Joaquín García Venegas y yo, Joaquín Alejandro España Sánchez.\\
    
    Por supuesto, ambos hacemos funciones totalmente distintas, por un lado la aplicación
    Android y por otro la aplicación web, sobre lo que nos centraremos en este proyecto.
    Ambos componentes son diferentes, pero en su conjunto forman \textbf{MyFindings},
    un proyecto completamente funcional. La página quedaría tal que así:

        \begin{figure}[H]
            \centering
            \includegraphics[scale=0.23]{imagenes/team.png}
            \caption{Equipo de MyFindings}
            \label{fig:team}
        \end{figure}

    En este caso se ha utilizado una estructura de página muy parecida a la anterior, utilizando
    dos \textit{rows}, el primero para el \textbf{\textit{headline}} y el segundo para los
    \textbf{miembros} del proyecto. Cabe mencionar el uso de la clase \textbf{\textit{border-box}}
    en numerosas ocasiones en el código, este incorpora un borde naranja al componente que lo posea.

    \subsubsection{Contacto}
    Finalmente, tenemos la página de contacto de la aplicación web, en ella podemos
    encontrar datos como el correo electrónico del desarrollador y su página de
    \href{https://github.com/alexespana/}{Github} o un mapa del lugar de residencia del
    programador, en este caso Granada.\\

        \begin{figure}[H]
            \centering
            \includegraphics[scale=0.20]{imagenes/contact.png}
            \caption{Contacto de MyFindings}
            \label{fig:contact}
        \end{figure}

    Para realizar esta página se ha hecho uso de tres filas, la primera de ellas
    está destinada al \textbf{\textit{headline}}, que como hemos visto, es común en otras
    páginas, por lo que usan la misma clase de estilo CSS. La segunda a su vez está
    dividida en dos partes utilizando cada una 6 columnas y finalmente la tercera fila ha
    sido destinada para el \textbf{\textit{iframe}} de Google Maps cuyo código HTML ha sido
    extraído directamente de la aplicación web y puesto sobre el código.

\subsection{Creación de la base de datos}
Este \textit{milestone} es uno de los más importantes del proyecto, ya que tiene como
principal objetivo la definición de la base de datos que se utilizará, que posteriormente
nos permitirá hacer las consultas apropiadas según las necesidades que busca el cliente,
en este caso los arqueólogos.\\

No prestarle atención a este hito sería un grave error, ya que si se realiza un mal diseño
de la BD puede conducir a las siguientes consecuencias en el desarrollo de \textit{software}:

    \begin{itemize}
        \item El proyecto podría \textbf{fallar} al no soportar los requerimientos de la
        aplicación.
        \item Si hay un diseño muy complejo, el costo de desarrollo se verá
        \textbf{incrementado}, ya que habrá que implementar más código para solucionar las
        distintas dificultades de la BD.
        \item Una base de datos compleja puede tener \textbf{gran cantidad de tablas} que 
        provocan código innecesario y complejo de entender.
        \item Posibles relaciones erróneas entre los datos que pueden llegar a provocar
        \textbf{fallos en la actualización} de los mismos y que finalmente sea necesario realizar
        actualizaciones manuales.
    \end{itemize}

En este caso, necesitamos utilizar una \textbf{base de datos relacional}, ya que gran número
de tablas están relacionadas entre sí, existiendo claves externas e incluso claves
candidatas que se forman a partir de claves primarias y atributos discriminadores de
relaciones. Todo esto se verá en la sección siguiente.

    \subsubsection{Modelo E/R}
    El modelo E/R es la técnica de modelado de datos más extendida para el diseño
    conceptual, ya que posee una gran capacidad expresiva (a simple vista se pueden
    distinguir las distintas entidades con sus atributos y relaciones), es rigurosa, simple
    y fácil de emplear. Nos permite especificar las necesidades de información de nuestro
    proyecto permitiéndonos hacer un diseño \textbf{apropiado},
    \textbf{de calidad} y \textbf{fácil de transmitir}.\\

    Para realizar dicho diseño, se ha hecho conjuntamente con Joaquín García Venegas,
    ya que para la aplicación Android también será necesario tener el diseño de la BD.
    Este modelo deberá:

        \begin{enumerate}
            \item Reflejar fielmente las necesidades de información del proyecto. Esto
            permite partir de una base para el desarrollo del sistema.
            \item Ofrecer un diseño independiente a la forma en que los datos serán
            posteriormente almacenados y sus formas de acceso, permitiendo tomar decisiones
            objetivas sobre la implementación más idónea.
        \end{enumerate}

    Teniendo todo esto en cuenta, el modelo E/R resultante para nuestro proyecto es el
    siguiente (si por cuestiones de editor o de pantalla no se puede ver correctamente,
    ir al siguiente enlace 
    \url{https://drive.google.com/file/d/1CRU5W9OQKCQF8nEYkDnl53O0noaJ9DS6/view?usp=sharing}):

        \begin{figure}[H]
            \centering
            \includegraphics[scale=0.15]{imagenes/E-RModel.png}
            \caption{Modelo Entidad/Relación}
            \label{fig:e-rmodel}
        \end{figure}

    Por cuestiones de comodidad se ha dividido la imagen en secciones que se pueden ver
    ampliadas en las páginas siguientes. Si se desea ir directamente a una sección, pulse
    sobre la sección deseada: sección 1 (\textbf{\ref{fig:e-rmodel1}}), sección 2
    (\textbf{\ref{fig:e-rmodel2}}), sección 3 (\textbf{\ref{fig:e-rmodel3}}), sección 4
    (\textbf{\ref{fig:e-rmodel4}}), sección 5 (\textbf{\ref{fig:e-rmodel5}}) y sección 6
    (\textbf{\ref{fig:e-rmodel6}}).

        \begin{figure}[H]
            \centering
            \includegraphics[scale=0.40]{imagenes/E-R1.png}
            \caption{Modelo E/R: sección 1}
            \label{fig:e-rmodel1}
        \end{figure}

        \begin{figure}[H]
            \centering
            \includegraphics[scale=0.40]{imagenes/E-R2.png}
            \caption{Modelo E/R: sección 2}
            \label{fig:e-rmodel2}
        \end{figure}

        \begin{figure}[H]
            \centering
            \includegraphics[scale=0.40]{imagenes/E-R3.png}
            \caption{Modelo E/R: sección 3}
            \label{fig:e-rmodel3}
        \end{figure}

        \begin{figure}[H]
            \centering
            \includegraphics[scale=0.50]{imagenes/E-R4.png}
            \caption{Modelo E/R: sección 4}
            \label{fig:e-rmodel4}
        \end{figure}

        \begin{figure}[H]
            \centering
            \includegraphics[scale=0.35]{imagenes/E-R5.png}
            \caption{Modelo E/R: sección 5}
            \label{fig:e-rmodel5}
        \end{figure}

        \begin{figure}[H]
            \centering
            \includegraphics[scale=0.35]{imagenes/E-R6.png}
            \caption{Modelo E/R: sección 6}
            \label{fig:e-rmodel6}
        \end{figure}


    Vamos a comenzar justificando las elecciones más importantes que se han ido tomando
    sobre el modelo, para ello seguiremos el siguiente orden: \textbf{entidades fuertes},
    \textbf{herencia}, \textbf{entidades débiles} y \textbf{relaciones}.

    \subsubsection{Entidades fuertes}
    Como podemos observar, hay siete entidades fuertes, entre las que podemos destacar,
    además de los atributos necesarios que no son claves primarias o candidatas,
    lo siguiente (algunas entidades tienen enlaces a sus definiciones, clicar encima):

    \begin{enumerate}
        \item \textbf{Excavación}: esta tendrá un identificador interno en la base de
        datos que actuará como \textit{primary key}, que será un valor numérico y, además,
        una clave candidata que será el \textbf{número de excavación}, un entero de tres dígitos
        (p.ej: 001, 043, 132, etc.). Esta clave candidata será la visible al usuario, pudiendo
        introducir el número de excavación deseado.

        \item \textbf{\gls{UE}}: al igual que la anterior, tendremos un
        identificador interno que será la \textit{primary key} y, además, una clave candidata
        que será el \textbf{código} de la unidad estratigráfica, que servirá para que el
        usuario pueda identificar dicha unidad. Dicho código debe estar formado por el
        \textbf{número de excavación} al que pertenece la unidad más el \textbf{número de orden}
        de la unidad en la excavación. Por ejemplo, si la unidad pertenece a la excavación
        \textbf{001} y es la unidad número 32 encontrada en la excavación (\textbf{032}), el
        código que identificaría a la unidad sería el \textbf{001032}.

        \item \textbf{\gls{Hecho}}: la forma que tiene el usuario de identificar a cada hecho es algo
        más compleja. Al igual que las dos entidades anteriores, también se tendrá un
        identificador interno que actuará de \textit{primary key} y, además, se tendrá una clave
        candidata compuesta, que estará formada por la \textbf{letra} (tipo de hecho) y un
        \textbf{número}. Para poder darle un valor coherente a este número, se elige una
        unidad estratigráfica perteneciente al hecho y el código de dicha unidad será el
        número (\textbf{parte de la clave candidata}) de dicho hecho. Por ejemplo, si tenemos
        la unidad estratigráfica con código \textbf{001032} y dicha unidad es la que sirve
        para identificar al hecho de tipo muro (\textbf{MR}) la clave candidata del hecho
        sería \textbf{MR001032}.

        \item \textbf{\gls{Estancia}}: en este caso, al igual que las entidades anteriores,
        tendremos un identificador interno como \textit{primary key} que solo se conocerá
        internamente en el sistema y, además, tendremos un \textbf{número de estancia}, que será
        la clave candidata de la entidad, visible y reconocible para los usuarios de la aplicación.
        Al comienzo del diseño pensábamos que el número de estancia se formaba a partir del número
        de sector y el número de zona, como está reflejado en el anexo \ref{subsec: doubts},
        pero finalmente este está formado por las letras ES seguidas de tres dígitos. Por ejemplo
        un posible identificador de estancia podría ser \textbf{ES001}.

        \item \textbf{Fotografía}: poseeremos un \textit{primary key} interno para la entidad y una
        clave candidata que será el \textbf{número} de la fotografía. Las fotografías están
        relacionadas tanto con las unidades estratigráficas como con las estancias, y es que 
        ambas pueden tener fotografías concretas.
        
        \item \textbf{Material construido}: esta entidad surge porque una unidad estratigráfica
        construida puede estar construida con \textbf{varios tipos de materiales} construidos,
        de ahí el hecho de que no se pueda poner simplemente un atributo que sea material en
        la unidad construida y se tenga que añadir una nueva entidad.

        Al comienzo podría pensarse que el material es una entidad débil de la unidad
        construida, pero esto traería problemas, ya que para identificar a un material sería
        necesario el identificador de la unidad estratigráfica y el atributo discriminador de
        la entidad débil. Esto carecería de sentido, ya que podría haber dos UE construidas
        con el mismo material, pero cada uno se identificaría de una forma distinta, a pesar
        de ser el mismo material. Por esta razón se consideró como una entidad fuerte, a la
        que muchas unidades estratigráficas construidas pueden estar asociadas. Tiendo esto
        en cuenta, esta vez no tendremos un \textit{primary key} interno, sino que el
        \textbf{nombre} del material será la \textit{primary key}. Por ejemplo: el material
        \textbf{Piedra} pudiese formar parte de 50 unidades construidas, siendo únicamente
        necesario el \textbf{nombre} del material para identificar a uno.
        
        \item \textbf{Material sedimentario}: esta entidad, al igual que la anterior, surge
        porque una unidad estratigráfica sedimentaria puede estar construida con 
        \textbf{varios tipos de materiales} sedimentarios, de ahí el hecho de que no se pueda
        poner simplemente un atributo que sea material en la unidad sedimentaria y se tenga que
        añadir una nueva entidad.

        En este caso también podríamos pensar que el material es una entidad débil de la unidad
        sedimentaria, pero esto también traería problemas, ya que para identificar a un material
        sería necesario el identificador de la unidad sedimentaria y el atributo discriminador
        de la entidad débil, que en este caso sería el \textbf{nombre}. Como hemos mencionado
        anteriormente, no tiene sentido, ya que podría haber dos UE sedimentarias hechas
        con el mismo material, pero cada uno se identificaría de una forma distinta, a pesar
        de ser el mismo material. Por esta razón se consideró como una entidad fuerte, a la
        que muchas unidades estratigráficas sedimentarias pueden estar asociadas. Igual que el
        anterior, la \textit{primary key} sería el \textbf{nombre} del material. Por ejemplo: el
        material \textbf{Metal} pudiese formar parte de 10 unidades sedimentarias, siendo
        únicamente necesario el \textbf{nombre} del material para identificar a uno. 
    \end{enumerate}

    \subsubsection{Herencia}
    Como podemos comprobar en el modelo E/R, existen claramente dos entidades que heredan de
    la entidad fuerte Unidad Estratigráfica, la \textbf{Sedimentaria} y la \textbf{Construida}.
    Ambas heredarán todos los atributos de la entidad padre y, además, añadirán sus propios
    atributos. En las fichas de registro de campo completo \ref{sec:registrationforms} puede
    verse en la UE construida cómo existe un apartado material, sin embargo, en la sedimentaria
    no existe una sección como tal, la pregunta sería: \textbf{¿por qué las UE sedimentarias
    tienen un material distinto entonces?} Tras numerosas entrevistas con el arqueólogo al
    final se dedujo que los materiales de la primera hoja de \ref{sec:registrationforms}
    correspondian a materiales que solo las UE sedimentarias podían tener, por esta razón
    se incorporaron.

    \subsubsection{Entidades débiles}
    La única entidad débil del modelo E/R es la \textbf{\gls{Inclusion}}. Dicha entidad surge
    porque una inclusión posee distintos atributos como la \textbf{frecuencia}, el \textbf{grosor}
    y el \textbf{tipo}, por lo que habría que modelarlos como una entidad que recogiese todos estos
    datos, además de que una unidad sedimentaria podría tener varias de ellas. En este caso, sí
    tiene sentido reflejarla como una \textbf{entidad débil}, ya que las inclusiones son propias de
    cada UE y no se comparten con otras unidades sedimentarias.\\

    Por lo tanto, estaría identificada por el \textbf{identificador} de la unidad estratigráfica
    sedimentaria y el atributo discriminador de la entidad débil que en este caso es el
    \textbf{tipo} (que puede ser cenizas, carbones, huesos, adobe, etc.).

    \subsubsection{Relaciones}
    Finalizando con las relaciones, vamos a enumerar las distintas relaciones identificando las
    entidades implicadas:

        \begin{enumerate}
            \item \textbf{Compuesta por (Excavación-UE)}: relación uno a muchos (1:M). En la
            relación se guarda el número de orden de la unidad estratigráfica.
            \item \textbf{Pertenece a (UE-Hecho)}: relación muchos a uno (M:1).
            \item \textbf{Identifica (UE-Hecho)}: relación uno a muchos (1:M).
            \item \textbf{Corresponde a (Hecho-Estancia)}: relación muchos a 1 (M:1).
            \item \textbf{Tiene (Estancia-Fotografía)}: relación uno a muchos (1:M).
            \item \textbf{Incluye (Fotografía-UE)}: relación muchos a uno (M:1).
            \item \textbf{Contiene (Sedimentaria-Inclusión)}: relación 1 a muchos (1:M).
            \item \textbf{Formado por (Sedimentaria-Material sedimentaria)}: relación muchos a
            muchos (M:N).
            \item \textbf{Elaborado de (Construida-Material construida)}: relación muchos a
            muchos (M:N).
        \end{enumerate}

    \subsubsection{Django ORM}

    Ahora vamos a hablar un poco sobre la implementación \textbf{en el código}, en la forma
    de representar el modelo E/R en nuestra aplicación \textbf{Django}.\\

    \paragraph{¿Qué es un ORM?} \underline{}                                            
    \newline Antes de nada, vamos a explicar qué es un \textbf{ORM (\textit{Object Relational
    Mapping})}, ya que será un concepto clave para entender lo posteriormente explicado. Un ORM
    es un modelo de programación que nos permite mapear las estructuras de una base de datos
    relacional sobre unas estructuras lógicas en el código (por ejemplo objetos), es decir, nos
    permite convertir los objetos de nuestra aplicación en un formato adecuado (SQL) para ser
    almacenado en la base de datos. Como todo en la vida, esto tiene unas ventajas y unas
    desventajas, comencemos por las ventajas:

        \begin{enumerate}
            \item Hacen que el proceso de desarrollo sea más rápido.
            \item No se necesita tener \textbf{conocimiento de SQL} para usar el ORM. Esto
            hace que la complejidad del DML se reduzca, evitando tener que hacer
            \textit{joins}, multiinserciones, subselecciones, etc.
            \item El ORM asegura la consulta para cualquier tipo de ataque.
        \end{enumerate}

    A pesar de tener cosas muy buenas, el ORM también tiene algunos aspectos que podrían
    considerarse pequeñas desventajas:

        \begin{enumerate}
            \item Los ORM generan una consulta y la pasan a la base de datos. En ocasiones
            estas consultas devuelven una matriz con un formato complejo con
            \textbf{colecciones} (objetos) que tienen información no relevante para nosotros.
            \item Cuando la lógica de negocio de la aplicación se vuelve compleja, a veces
            no se puede representar mediante un ORM, aunque sí pueda ser manejable a nivel
            de consulta.
        \end{enumerate}

    Dicho todo esto, podemos comenzar a hablar sobre el ORM que utilizaremos para la
    aplicación web, el \textbf{ORM de Django}. Este nos permite diseñar nuestras tablas de 
    base de datos sin necesidad de escribir ninguna sentencia SQL, en este caso, en
    \textbf{PostgreSQL}. Un modelo es la fuente de información única y definitiva para los
    datos, este contendrá los campos y funcionalidades (comportamiento) correspondientes a
    la naturaleza de los datos que almacena. Normalmente, cada modelo se asigna a una sola
    tabla de base de datos, y cada uno de ellos:

        \begin{itemize}
            \item Es una clase de Python que hereda de la clase \textbf{django.db.models.Model}.
            \item Cada atributo de la clase representa un campo (columna) de la base de datos.
            \item Al corresponderse cada entidad a una clase, Django proporciona automáticamente
            una \textbf{API de abstracción de bases de datos} que nos permite realizar las
            operaciones de \textbf{CRUD} básicas: crear, recuperar, actualizar y eliminar
            objetos.
        \end{itemize}

    Cada modelo visible para el usuario tiene una función \textbf{\textit{str}} que se
    corresponde con la identificación del objeto al mostrarlo al usuario. Digamos que se
    trata de un método especial que devuelve una representación en forma de \textbf{string} de
    cualquier objeto y que Python y Django utilizarán cada vez que una instancia de un 
    modelo necesite ser mostrada como una cadena, como puede ser en el caso de la consola
    interactiva, en la vista de administrador, en un \textit{display} de una tabla, etc.\\

    Pongamos un ejemplo, si la unidad estratigráfica posee una \textbf{clave externa} que es
    la \textbf{excavación} a la que pertenece, dicha instancia de excavación se mostraría
    para el usuario como el \textbf{número de excavación}, ya que en el modelo de la
    excavación existirá un método str que devolvería el \textbf{n\_excavacion},
    quedando el modelo de la siguiente forma:

    
    \begin{minted}[mathescape, linenos,numbersep=5pt,bgcolor=lightgray,gobble=2,
                   frame=lines,fontsize=\footnotesize,framesep=2mm]{python}
    class Excavation(models.Model):
        class Meta:
            verbose_name = 'excavación'
            verbose_name_plural = 'excavaciones'

        nombre = models.CharField(max_length=100,
                    verbose_name='Nombre de la excavación',
                    blank=True, null=True)

        # Ej. 001, 002, 003, etc
        n_excavacion = models.CharField(max_length=3,
                        verbose_name='Número de excavación',
                        help_text='Ej. 001, 002, 003, etc', 
                        validators=[validate_number], unique=True)      
        latitud = models.FloatField(blank=True, null=True)
        longitud = models.FloatField(blank=True, null=True)
        altura = models.PositiveSmallIntegerField(blank=True, null=True)

        def __str__(self):
            return str(self.n_excavacion)
    \end{minted}

    Si nos fijamos, vemos que es necesario que esta función devuelva un string, por esta
    razón se usa la función str en el return. Además, Django nos proporciona \textbf{gran
    variedad de tipos posibles} para los campos de los modelos, por lo que nos podemos
    ahorrar hacer algunas comprobaciones en los formularios de recogida de datos, aunque
    algunas serán necesarias. Aquellos campos que necesiten ser positivos
    utilizarán campos de tipo \textbf{PositiveSmallIntegerField}, que nos permite introducir
    enteros desde el 0 hasta el 32767, cantidades suficientes para el contexto de nuestro
    proyecto.\\

    Lo siguiente va a ser explicar cómo representar en los modelos las
    \textbf{\textit{primary keys}}, \textbf{\textit{candidate keys}} y
    \textbf{\textit{relationships}}.\\
    
    \paragraph{Claves primarias} \underline{}
    \newline En los atributos de los modelos, en los tipos de campo, existe un parámetro llamado
    \textbf{primary\underline{ }key}, si se indica a True, entonces dicho campo será la clave
    primaria del modelo, pero si no se indica el \textit{primary key} en ningún campo del modelo,
    entonces Django automáticamente añadirá un campo \textbf{id} para guardar la clave primaria.
    Dicho atributo será un campo de tipo \textbf{models.BigAutoField}, que nos permite números
    desde el 1 hasta el 9223372036854775807, por lo que no habrá ningún tipo de problema con
    la generación de los id. Por supuesto, si en algún campo se declara \textbf{explícitamente}
    la clave primaria, Django no generará el campo id y el campo que hayamos elegido pasará a
    ser clave primaria. En nuestro modelo E/R, las claves primarias que se generarán
    automáticamente por Django en los modelos serán las de \textbf{Excavacion, UE, Hecho,
    Estancia y Fotografia}. 
    
    \paragraph{Claves candidatas} \underline{}
    \newline Para las \textbf{claves candidatas simples} únicamente hay que indicar en el campo
    correspondiente al argumento \textbf{unique} a True. Por ejemplo, en el modelo
    \textbf{Excavación} mostrado anteriormente el campo del número de excavación es
    \textit{candidate key}:
    
    
    \begin{minted}[mathescape, linenos,numbersep=5pt,bgcolor=lightgray,gobble=2,
                   frame=lines,fontsize=\footnotesize,framesep=2mm]{python}
    class Excavacion(models.Model):
        n_excavacion = models.PositiveIntegerField(unique=True, 
                        verbose_name='Número de excavación')
        .
        .
    \end{minted}

    ¿Cómo se representaría una clave candidata compuesta? En Django, esto se puede hacer de
    dos formas:

    \begin{enumerate}
        \item Mediante la opción \textbf{unique\underline{ }together}, que incluye la lista
        de campos que formarán la clave candidata, y que por lo tanto conjuntamente serán
        únicos. Vamos a hacer el ejemplo con el modelo Hecho, ya que es el único que tiene
        una clave candidata compuesta:
        
    
    \begin{minted}[linenos,numbersep=5pt,bgcolor=lightgray,gobble=2,
        frame=lines,fontsize=\footnotesize,framesep=2mm]{python}
    class Excavacion(models.Model):
        letra = models.CharField(max_length=2, choices=LETRA_CHOICES)
        numero = models.CharField(max_length=6)    
        .
        .
        class Meta:
            unique_together = ('letra', 'numero',)
    \end{minted}

        \item La forma anterior, sin embargo, no es del todo aconsejable por Django ya
        que sugiere utilizar \textbf{UniqueConstraint} con la opción \textbf{constraint},
        ya que la opción de \verb|unique_together| ofrece menor funcionalidad y puede
        estar obsoleta (\textit{deprecated}) en un futuro. Con esta nueva forma, la clase
        de metadatos del modelo quedaría así:
        
    
    \begin{minted}[linenos,numbersep=5pt,bgcolor=lightgray,gobble=2,
        frame=lines,fontsize=\footnotesize,framesep=2mm]{python}
    class Excavacion(models.Model):
        letra = models.CharField(max_length=2, choices=LETRA_CHOICES)
        numero = models.CharField(max_length=6)    
        .
        .
        class Meta:
            constraints = [
                models.UniqueConstraint(fields=['letra', 'numero'], 
                                        name='fact_constraint')                                                  
            ]
    \end{minted}

    Dicha restricción tendrá el nombre de \textbf{fact\underline{ }constraint}.
    \end{enumerate}

    \paragraph{Relaciones} \underline{}
    \newline Django soporta las mismas tres relaciones que existen en una base de datos relacional:
    uno a uno, uno a muchos, y muchos a muchos. Para representarlas, usa tres tipos de campos
    para los modelos, que son:

        \begin{itemize}
            \item \textbf{OneToOneField}: en uno de los modelos implicados, recibe como
            argumentos básicos el nombre del modelo con el que está asociado y el argumento
            del borrado en cascada (\textbf{on\underline{ }delete}).
            \item \textbf{ForeignKey}: en el modelo de la parte \textbf{muchos}, irá un campo
            con el nombre del modelo asociado en minúscula y de tipo ForeignKey, recibiendo
            como parámetros el nombre del modelo asociado (parte del uno) y el argumento del
            borrado en cascada.
            \item \textbf{ManyToManyField}: este tipo de relaciones son algo más complejas. Al
            ser una relación M:N podemos pensar que en cada uno de los modelos irá un campo
            ManyToManyField, pero esto no es así. En el modelo donde tenga más lógica que vaya
            el campo muchos a muchos irá un campo con el nombre del otro modelo en plural (por
            \textbf{convención}) con el dato de tipo ManyToManyField, que recibe como parámetro
            únicamente el nombre del modelo con el que se relaciona.

            Por ejemplo, tengamos los modelos \textit{Pizza} y \textit{Topping}, ¿qué se
            entiende mejor? \textbf{¿que una \textit{pizza} pueda tener muchos
            \textit{toppings}?}, \textbf{¿o que un \textit{topping} pueda estar en muchas
            \textit{pizzas}?} La primera de las opciones es más intuitiva y por tanto el
            modelo \textit{Pizza} tendría un campo \textit{toppings} de tipo ManyToManyField.
        \end{itemize}

    Explicadas las formas de representar las relaciones en Django, vamos a mencionar las
    relaciones que se dan en nuestro modelo:

        \begin{enumerate}
            \item El \textbf{hecho} tiene una clave externa referenciando a la estancia a
            la que está asociado.
            \item La \textbf{unidad estratigráfica} tiene dos claves externas, una
            referenciando a la excavación con la que está asociada y otra referenciando al
            hecho al que pertenece.
            \item La \textbf{fotografía} tiene también dos claves externas, una
            referenciando a la unidad estratigráfica asociada y otra referenciando a la
            estancia.
            \item La \textbf{inclusión} tiene una clave externa referenciando la unidad
            estratigráfica sedimentaria a la que pertenece.
            \item La \textbf{unidad sedimentaria} tiene un campo ManyToManyField
            referenciando a los materiales sedimentarios por los que está formada.
            \item La \textbf{unidad construida} tiene un campo ManyToManyField referenciando a
            los materiales construidos por los que está formada.
        \end{enumerate}

    Esta sería una visión global de la implementación utilizando el ORM que nos ofrece Django.

\newpage \subsubsection{Generación de informes}
Una de las funcionalidades más prácticas de nuestra aplicación es la \textbf{generación
automática de informes}. A través de esta funcionalidad, podemos generar informes a partir
de la información almacenada de una determinada excavación en la base de datos. \\

Por ahora, el formato de salida disponible es \textbf{docx}, el formato por defecto de
Microsoft Word, aunque en el futuro no se descarta la posibilidad de generar informes
en otros formatos. Principalmente hemos elegido este formato porque es más flexible,
permitiendo la edición del documento y la posterior transformación a PDF desde el propio
editor. \\

Para la implementación de esta funcionalidad, se ha utilizado una biblioteca de Python
llamada \href{https://python-docx.readthedocs.io/en/latest/}{\textbf{python-docx}}, que nos
permite generar documentos mediante instancias de la clase \textbf{docx.Document}. A
través de una instancia de esta clase, se van añadiendo los párrafos, títulos, tablas,
imágenes, etc., que se deseen, y finalmente, se guarda mediante el método \textbf{save}.
Pongamos un ejemplo sencillo (se han añadido comentarios en el propio código para una mejor
comprensión):


\begin{minted}[mathescape, linenos,numbersep=5pt,bgcolor=lightgray,gobble=2,
    frame=lines,fontsize=\footnotesize,framesep=2mm]{python}
    import io
    from docx import Document
    .
    .
    # Crear instancia
    document = Document()
    # Añadir nuevo párrafo
    document.add_pparagraph('Hola')
    # Variable que contendrá los bytes del archivo
    document_data = io.BytesIO()
    # Se guarda el contenido en la variable document_data
    document.save(document_data)
    # Dar una respuesta HTTP para descargar el fichero
    response = HttpResponse(document_data.getvalue())
    # Darle nombre al fichero
    response["Content-Disposition"] = 'attachment;
                        filename = "Informe de excavación.docx"'
    # Para codificar los datos
    response["Content-Encoding"] = "UTF-8"
\end{minted}

Con este ejemplo, tendríamos como resultado un documento con \textbf{extensión .docx}
conteniendo un párrafo con el texto \textit{Hola}. Este sería un ejemplo sencillo, pero
puede verse una ejemplo más complejo y completo en el código fuente de la aplicación
(\href{https://github.com/alexespana/TFG/blob/master/code/app/myFindings/views.py}
{\textbf{archivo views.py de la rama master}}). \\

El resultado de esta implementación en la aplicación sería el siguiente:

    \begin{figure}[H]
        \centering
        \includegraphics[scale=0.54]{imagenes/report-generator1.png}
        \caption{Generación de informes (Parte 1)}
        \label{fig:report-generator1}
    \end{figure}

    \begin{figure}[H]
        \centering
        \includegraphics[scale=0.54]{imagenes/report-generator2.png}
        \caption{Generación de informes (Parte 2)}
        \label{fig:report-generator2}
    \end{figure}

Asimismo, si en dicha excavación los hechos tuviesen fotografías asociadas, las mismas
se incluirían en el documento.

\subsection{Autenticación}
En este \textit{milestone} del proyecto se ha trabajado sobre la autenticación y
autorización de usuarios en la aplicación web. A continuación se explicará todo lo que se
ha implementado.\\

Django cuenta con un \textbf{sistema de de autenticación} \cite{django-auth} de usuarios,
este puede manejar cuentas de usuario, grupos de usuario, permisos, sesiones de usuario
basadas en \textit{cookies}, etc. Antes de nada, debemos de tener claro qué significan los
términos de autenticación y autorización:

    \begin{itemize}
        \item \textbf{Autenticación}: es un proceso en el que se verifica que un usuario
        es quién dice ser. Por ejemplo, una de las pruebas más comunes de autenticación
        es mediante la escritura de una contraseña.
        \item \textbf{Autorización}: en este caso, se determina lo que un usuario
        autenticado puede hacer en el sistema, es decir, los permisos que este posee. Por
        ejemplo, en nuestro caso, si puede o no modificar una excavación.
    \end{itemize}

Todo lo requerido para la autenticación en Django está implementado en uno de sus módulos,
concretamente en el módulo \textbf{django.contrib.auth}, que tendremos que añadir a
nuestro proyecto. Además, necesitaremos definir los permisos asociados a nuestros modelos,
por ejemplo, poder ver una excavacion, poder editarla, etc., para ello se usa el módulo
\textbf{django.contrib.contenttypes}, que también tendremos que añadir al proyecto.

\subsubsection{Vistas de autenticación}
En Django hay dos formas de implementar la autenticación de la aplicación: mediante la
definición de \textbf{tus propias vistas} o utilizando las vistas \textbf{ya predefinidas}
de Django. En nuestro caso hemos optado por la última opción, puesto que nos ofrece todo lo
necesario para nuestro propósito y hace mucho más sencilla la implementación.\\

Para aclarar un poco más esto último, si nos fijamos en la figura \ref{fig:mvt}, lo que
estaríamos usando ya de forma predefinida por Django serían las URL (\textbf{URL}) y las
vistas (\textbf{VIEW}), quedando a nuestro cargo la definición de las correspondientes
\textbf{plantillas/\textit{templates}} asociadas a cada una de las vistas y URL.\\

A continuación, se indican las rutas que se encuentran definidas en
\textbf{django.contrib.auth.urls} junto a la descripción de las funcionalidades de las
\textbf{plantillas/\textit{templates}} que renderizan:

    \begin{itemize}
        \item \textbf{accounts/login/}: es el \textit{template} desde el que los usuarios
        pueden iniciar sesión en la aplicación, es decir, autenticarse.
        \item \textbf{accounts/logout/}: cuando un usuario ya ha iniciado sesión y accede
        a esta URL, se cerrará su sesión automáticamente.
        \item \textbf{accounts/password\underline{ }change/}: permite a un usuario
        autenticado cambiar su contraseña en la aplicación.
        \item \textbf{accounts/password\underline{ }change/done/}: es el \textit{template}
        que muestra el resultado del cambio de contraseña.
        \item \textbf{accounts/password\underline{ }reset/}: en caso de olvido de contraseña,
        este \textit{template} permite a un usuario no logueado, introducir su correo para
        que se le envíe un enlace de recuperación de contraseña.
        \item \textbf{accounts/password\underline{ }reset/done/}: muestra el resultado de
        haber enviado el correo de recuperación de contraseña al usuario.
        \item \textbf{accounts/reset/<uidb64>/<token>/}: en este caso, la URL anterior
        envía un enlace de recuperación de contraseña al usuario, este enlace tiene el
        formato aquí indicado, \textbf{uidb64}, que sería el id del usuario codificado
        en base 64, y un \textbf{\textit{token}}, que es un \textit{token} de seguridad que
        se genera en el momento de la creación del enlace y verifica que la constraseña sea
        válida.
        \item \textbf{accounts/reset/done/}: este \textit{template} muestra un mensaje de
        confirmación tras el cambio de contraseña.
    \end{itemize}

\subsubsection{Registro de usuarios}
En este punto, dado que Django no ofrece ninguna vista ni URL ya definida para el registro
de usuarios, se ha procedido a incorporar a nuestra aplicación una ruta (register/),
una vista (register) y una plantilla (register.html). Desde la plantilla, un usuario no
registrado en el sistema podrá registrarse introduciendo su \textbf{nombre de usuario}, un
\textbf{correo electrónico} (necesario para poder recuperar la contraseña en caso de
olvido), la \textbf{contraseña} y una \textbf{confirmación de contraseña}.\\

Para el registro de usuarios, se ha decidido que se siga el siguiente flujo de acciones en
la aplicación:

    \begin{enumerate}
        \item Un usuario no registrado rellena el formulario de registro y lo envía. Ahora
        estaría registrado en el sistema, pero como un usuario \textbf{inactivo}, por lo
        que no podrá iniciar sesión en la aplicación.
        \item Al realizarse una solicitud de registro, se enviará un correo al administrador
        del sistema para que apruebe el registro del usuario.
        \item El administrador del sistema aprueba el registro del usuario, \textbf{activando}
        al usuario desde su panel de administración y dándole los permisos correspondientes.
        \item Se le notifica al usuario mediante correo electrónico que ya puede iniciar
        sesión en la aplicación.
    \end{enumerate}

\subsubsection{Envío de correos} \label{subsubsec:send-mails}
El envío de correos electrónicos es una parte importante de la aplicación, ya que se
utiliza para enviar correos de recuperación de contraseña, para activar usuarios, para
confirmar las activaciones, etc.\\

A pesar de que Python tiene una interfaz para enviar correos en el módulo de
\textbf{smtplib}, Django incorpora capas superiores para que el envío de los correos se
haga de forma mas rápida y para dar soporte a las plataformas que no puedan usar SMTP
\footnote{\textbf{\textit{Simple Mail Transfer Protocol}} es un protocolo que utilizan los servidores
de correo electrónico para enviar y recibir \textit{emails}.}.\\

En esta ocasión, se ha decidido usar el servidor de correo de Google, ya que es uno de los
más populares y seguros. Para ello, se han tenido que definir en la configuración de
Django ajustes como el \textit{backend} que se usará para enviar los correos, el host, el
puerto, indicar si se usa una conexión segura con TLS, el usuario y la contraseña, por
supuesto, estos dos últimos almacenados siempre en \textbf{variables de entorno} por temas
de seguridad.\\

En una primera aproximación a la solución final adoptada, Django se autenticaba con el
usuario y contraseña de correo indicados en \textbf{settings.py}, teniendo que permitir
el \textbf{acceso de aplicaciones menos seguras} explícitamente en Gmail para que Django
pudiera autenticarse.

    \begin{figure}[H]
        \centering
        \includegraphics[scale=0.38]{imagenes/apps-access.png}
        \caption{Acceso de aplicaciones menos seguras}
        \label{fig:apps-access}
    \end{figure}

Como vemos, esta opción no parece muy recomendable, ya que puede ser un punto vulnerable
en la seguridad de nuestra cuenta y de nuestra aplicación, por lo que finalmente se ha
decidido activar la autenticación en dos pasos y crear una contraseña de aplicación,
que estará en una variable de entorno junto al correo de la cuenta.

    \begin{figure}[H]
        \centering
        \includegraphics[scale=0.38]{imagenes/apps-pass.png}
        \caption{Contraseñas de aplicaciones}
        \label{fig:apps-pass}
    \end{figure}

\subsubsection{Permisos y roles de usuario}
Uno de los puntos más importantes de la aplicación es el manejo de permisos y roles de
usuario. Para el control de ello, Django viene integrado con un sistema de permisos,
que nos permite controlar qué usuarios pueden \textbf{ver}, \textbf{añadir}, \textbf{
modificar} o \textbf{eliminar} ciertos modelos de la aplicación. Por ejemplo, para el
manejo de los usuarios que pueden realizar acciones sobre excavaciones tendríamos:

    \begin{itemize}
        \item \textbf{Ver}: controlar qué usuarios pueden ver excavaciones desde las
        vistas.
    
    \begin{minted}[mathescape, linenos,numbersep=5pt,bgcolor=lightgray,gobble=2,
           frame=lines,fontsize=\footnotesize,framesep=2mm]{python}
    @login_required
    @permission_required('myFindings.view_excavation', 
                                        raise_exception=True)
    def list_allexcavations(request):
        # Get all excavations
        excavations = Excavation.objects.all()
        data = { 'excavations': excavations}
    
        return render(request, 'excavations_list.html', data)
    \end{minted}

        \item \textbf{Añadir}: controlar qué usuarios pueden añadir excavaciones
        desde las vistas.
    
    \begin{minted}[mathescape, linenos,numbersep=5pt,bgcolor=lightgray,gobble=2,
           frame=lines,fontsize=\footnotesize,framesep=2mm]{python}
    @login_required
    @permission_required('myFindings.add_excavacion', 
                                        raise_exception=True)
    def add_excavation(request):
        # Get the fields of excavation
        data = { 'form': ExcavationForm() }
    
        if request.method == 'POST':
            # Get the data entered by the user
            form = ExcavationForm(data=request.POST)
            if(form.is_valid()):    # Check if valid
                form.save()         # Save form
    
                # Redirect to the list of excavations
                return redirect(to='excavations')
            else:
                data['form'] = form
    
        return render(request, 'add_excavation.html', data)
    \end{minted}

        \item \textbf{Modificar}: controlar qué usuarios pueden modificar excavaciones
        desde las vistas.
    
    \begin{minted}[mathescape, linenos,numbersep=5pt,bgcolor=lightgray,gobble=2,
           frame=lines,fontsize=\footnotesize,framesep=2mm]{python}
    @login_required
    @permission_required('myFindings.change_excavation', 
                                        raise_exception=True)
    def modify_excavation(request, id):
        excavation = get_object_or_404(Excavation, id=id)
        
        # Guardar el formulario con los datos del cuadro
        data = { 'form': ExcavationForm(instance=excavation) }
    
        if request.method == 'POST':
            form = ExcavationForm(data=request.POST,
                                        instance=excavation)
            if form.is_valid():       # Si es válido
                form.save()           # Guardarlo
    
                return redirect(to="excavations")
    
            data["form"] = form
    
        return render(request, 'modify_excavation.html', data)
    \end{minted}

        \newpage \item \textbf{Eliminar}: controlar qué usuarios pueden eliminar excavaciones
        desde las vistas.
    
    \begin{minted}[mathescape, linenos,numbersep=5pt,bgcolor=lightgray,gobble=2,
           frame=lines,fontsize=\footnotesize,framesep=2mm]{python}
    @login_required
    @permission_required('myFindings.delete_excavation',
                                        raise_exception=True)
    def delete_excavation(request, id):
        # Get the excavation, if it doesn't exist, get an Http404
        excavation = get_object_or_404(Excavation, id=id)
    
        # Delete the excavation
        excavation.delete()    
    
        return redirect(to="excavations")
    \end{minted}
    \end{itemize}

Como vemos, en todas las vistas se hace uso de \textbf{decoradores} \cite{decorators},
que nos permiten controlar el acceso a estas. En este caso, el decorador
\textbf{@login\_required} nos permite controlar que el usuario esté autenticado,
y el decorador \textbf{@permission\_required} nos permite controlar que el usuario
tenga el permiso correspondiente.\\

Esto hace mucho más segura la aplicación, ya que si un usuario no autenticado intenta
acceder a alguna URL a la que no tiene permiso \textbf{escribiéndola directamente en
el navegador}, primero se comprobará que esté autenticado en el sistema, y en caso
contrario se le redirigirá a la página de inicio de sesión. Como vemos en la siguiente
imagen, el usuario ha intentado acceder a la página add\_excavation/ sin estar autenticado,
por lo que se le ha redirigido a la página de login para luego redirigirlo a la página
requerida (\textbf{?next=/add\_excavation/}).

    \begin{figure}[H]
        \centering
        \includegraphics[scale=0.26]{imagenes/login-required.png}
        \caption{Login requerido}
        \label{fig:login-required}
    \end{figure}


\newpage Una vez autenticado, se pasará al segundo decorador, que comprobará que tenga el permiso
correspondiente y en caso contrario, mostrará el mensaje \textbf{403 Forbidden}

    \begin{figure}[H]
        \centering
        \includegraphics[scale=0.50]{imagenes/403-forbidden.png}
        \caption{Permiso denegado}
        \label{fig:403-forbidden}
    \end{figure}

Otro de los temas importantes de la aplicación son los roles de usuario, que serían los
siguientes:

    \begin{enumerate}
        \item \textbf{Arqueólogo lector}: corresponde a un arqueólogo que únicamente tiene
        permisos de lectura, es decir, que no puede añadir, modificar o eliminar
        datos de excavaciones, aunque sí pueda verlos.

        \item \textbf{Arqueólogo editor}: tiene todos los permisos necesarios para añadir,
        modificar o eliminar excavaciones, hechos, unidades estratigráficas, etc. en la
        aplicación.

        \item \textbf{Arqueólogo administrador (\textit{Staff})}: en nuestra aplicación,
        corresponderá al arqueólogo con permisos privilegiados, que se encargará de aceptar
        o rechazar a los usuarios que envían peticiones de registro. Estos podrán
        \textbf{añadir y eliminar} a usuarios de grupos de permisos ya definidos, además de
        \textbf{tener acceso a todos los modelos} definidos en el sistema: excavaciones,
        inclusiones, materiales, etc.

        \item \textbf{Administrador del sistema}: es el usuario que tiene todos los permisos
        del sistema, puede realizar cualquier acción dentro de él: eliminar modelos, eliminar
        usuarios, crear grupos, cambiar permisos a usuarios concretos, etc.
    \end{enumerate}

\subsubsection{Panel de administración}
En todo sitio web, existe un panel de administración desde el que un usuario o usuarios
con privilegios pueden hacer acciones privilegiadas en la aplicación. Dado que Django
tiene su propio panel de administración \cite{admin-panel}, con multitud de funcionalidades
ya implementadas, se ha decidido reutilizar este.\\

Dicho panel será únicamente utilizado por el administrador del sistema, que en este caso
sería el desarrollador de este proyecto. Además, se ha querido hacer más atractiva
visualmente la interfaz utilizando una aplicación de terceros llamada
\textbf{django-admin-interface} \cite{admin-interface}, con la que podremos darle el
aspecto siguiente:

    \begin{figure}[H]
        \centering
        \includegraphics[scale=0.32]{imagenes/admin-interface.png}
        \caption{Panel de administración}
        \label{fig:admin-interface}
    \end{figure}

Como podemos observar, en él podremos definir grupos de usuarios con los permisos deseados,
ver los usuarios registrados en el sistema, modificarlos, eliminarlos, cambiar el diseño
de la interfaz (\textbf{Temas}), además de poder ver, añadir, modificar o eliminar
cualquier objeto perteneciente a los modelos que hemos definido en la aplicación.


\subsection{Testear comportamiento}
En este \textit{milestone} explicaremos por qué es tan importante realizar tests
durante el proceso de desarrollo y cómo los hemos llevado a cabo.\\

Los errores humanos en el desarrollo del \textit{software} son posibles y pueden causar
fallos o defectos en cualquier fase del desarrollo de este. Dichos errores pueden ser algo
trivial, \textbf{fácil} de solucionar, o algo más \textbf{complejo}, que pueda requerir
tiempo y un coste elevado para solucionarlo. Dichos errores pueden evitarse con un correcto
testeo durante la fase del desarrollo del \textit{software}, ya que gracias a él
podremos \cite{why-testing}:

    \begin{itemize}
        \item \textbf{Detectar errores} durante el desarrollo del \textit{software}.
        \item Hacer que el \textit{software} desarrollado tenga una \textbf{mayor calidad y
        fiabilidad}.
        \item \textbf{Cumplir los requisitos} especificados por el cliente, y por lo tanto,
        que el cliente esté satisfecho.
        \item Obtener un funcionamiento \textbf{fiable y de alto rendimiento}.
        \item Evitar que en \textbf{\textit{releases}}\footnote{\textbf{Lanzamiento}
        (publicación) de una versión definitiva del \textit{software}.} puedan introducirse
        errores.
    \end{itemize}

Poniendo un ejemplo, supongamos que queremos enviar una cantidad de dinero a través de
Bizum a un amigo, se comienza la \textbf{transacción} y se le envía el dinero al
destinatario, finalmente se le envía un mensaje de confirmación. Sin embargo, nuestro amigo
dice que no ha recibido ningún ingreso en su cuenta y nosotros tampoco vemos que en nuestra
cuenta se haya anulado el envío del dinero. Esta situación nos generará molestia y no
estaremos satisfechos con el servicio. ¿Por qué sucede esto? Sucede por un testeo
incorrecto o inexistente antes de lanzar el producto (\textbf{\textit{release}}).\\

El testeo de una aplicación web es una tarea difícil, ya que está compuesta por varias
capas lógicas, que van desde el manejo de \textbf{solicitudes HTTP}, pasando por la
\textbf{validación y procesamiento de formularios}, hasta la \textbf{visualización de las
plantillas}. Para realizar todas estas tareas, Django tiene un marco de ejecución de
pruebas con el que se pueden simular solicitudes HTTP, insertar datos de prueba y, en
general, comprobar que el código funciona como se espera.\\

Antes de nada, vamos a explicar la jerarquía de clases que existe para el testeo de la
aplicación:

    \begin{figure}[H]
        \centering
        \includegraphics[scale=0.60]{imagenes/classes-hierarchy.png}
        \caption[Jerarquía de las clases para pruebas unitarias.]{Jerarquía de las
        clases para pruebas unitarias. Fuente \cite{classes-hierarchy}}
        \label{fig:classes-hierarchy}
    \end{figure}

Como podemos observar, la clase padre de la que el resto hereda todas sus funcionalidades
es la clase \textbf{TestCase}, que se encuentra en el módulo \textbf{unittest} de la
biblioteca estándar de Python. A continuación, vamos a explicar brevemente las subclases
que implementa el \textit{framework} de test de Django:

    \begin{itemize}
        \item \textbf{SimpleTestCase}: esta clase añade numerosas funcionalidades a la
        clase base del módulo de Python. Normalmente, se utiliza cuando no se consulta a
        la base de datos.
        \item \textbf{TransactionTestCase}: esta clase añade más funcionalidades a la
        clase SimpleTestCase. Esta clase y TestCase (siguiente punto) son idénticas
        excepto por la forma en que la base de datos se restablece.
        \item \textbf{TestCase}: esta clase es la más utilizada para escribir tests en
        Django. En nuestros tests, hemos utilizado esta clase, ya que nuestra aplicación
        usa una base de datos y será necesaria.
        \item \textbf{LiveServerTestCase}: esta clase es la más peculiar de todas, ya que
        hace lo mismo que TransactionTestCase, pero además, permite que se ejecuten
        \textbf{tests visuales}, es decir, tests en los que se abre un navegador y se
        simulan acciones reales de un usuario, verificando que la página se comporta
        como es debido. Por ejemplo, al pulsar un botón, al iniciar sesión, al ver las
        unidades estratigráficas, etc.
    \end{itemize}

\subsubsection{Base de datos de tests}
Como hemos comentado anteriormente, existen tests que requerirán una base de datos para
funcionar (aquellos que heredan de \textbf{TestCase} de Django). Esta base de datos no debe
ser la base de datos real, es decir, la de producción, ya que al finalizar los tests podría
quedar en un estado inválido o desconocido. Para ello, Django crea una base de datos nueva
en el momento en que se ejecutan los tests, que tendrá la misma configuración que la
indicada en el archivo \textbf{settings.py} del proyecto y que, además, se eliminará al
finalizar los tests.\\

Para lanzar los tests en Django se tiene que usar el comando \textbf{test} de la utilidad
\textbf{manage.py} de nuestro proyecto que, básicamente, es un archivo ejecutable con el
que se pueden ejecutar los comandos del proyecto Django, comandos relacionados con modelos,
migraciones, tests, etc. Veamos un sencillo ejemplo de lanzamiento de tests:

    \begin{figure}[H]
        \centering
        \includegraphics[scale=0.40]{imagenes/db-test.png}
        \caption{Base de datos para \textit{testing}}
        \label{fig:db-test}
    \end{figure}

Debemos recordar que nosotros, al inicio del desarrollo del \textit{software}, decidimos
lanzar el proyecto usando \textbf{Docker} \cite{docker} y \textbf{Docker Compose}
\cite{docker-compose}, es decir, \textit{dockerizándolo}, por esta razón lanzamos
los tests desde el contenedor.\\

Como vemos, lo primero que se hace es crear la base de datos para \textit{testing},
posteriormente se ejecutan los tests (cada punto indica la ejecución correcta de un test)
y finalmente, se destruye la base de datos creada al principio.\\

En este caso, si quisiéramos ver con más detalle lo que sucede, podríamos indicar en el
comando la opción \textbf{-v <nivel>} (\textit{verbosity}) en el que el nivel indica la
profundidad de detalle (0,1,2,3). En este caso, dado que la salida es demasiado extensa,
no se aporta la imagen. Si ejecutásemos los tests con un nivel dos o superior podríamos
ver cómo Django, antes de lanzar los tests, realiza todas las \textbf{migraciones} de las
base de datos, teniendo de esta forma un entorno independiente para el testeo de la
aplicación y dejando la base de datos usada en producción en el mismo estado que al
comienzo de los tests.\\

\subsubsection{Lanzamiento de tests}
Por defecto, Django incorpora en su estructura base de proyecto un archivo llamado
\textbf{tests.py}, donde se podrán escribir todos los tests necesarios para el proyecto.
Sin embargo, dado que nuestra aplicación tiene miles de líneas de código, se ha decidido
crear un directorio llamado \textbf{tests} y dentro de él, todos los archivos (módulos) de
tests que sean necesarios. Concretamente, hemos creado los siguientes archivos:

    \begin{itemize}
        \item \textbf{tests/\underline{  }init\underline{  }.py}: este archivo es el
        encargado de importar todos los módulos de tests que se encuentren en el
        directorio \textbf{tests}.
        \item \textbf{tests/test\_urls.py}: este archivo contiene los tests de las URL de la
        aplicación. Comprueba que las URL de la aplicación estén vinculadas siempre a sus
        correpondientes vistas.
        \item \textbf{tests/test\_settings.py}: este archivo contiene los tests de los
        \textit{settings} de la aplicación. Comprueba que ciertas variables esenciales en
        la aplicación estén correctamente declaradas. Por ejemplo, que la
        \textbf{SECRET\_KEY} de la aplicación esté siempre declarada en una variable de
        entorno.
        \item \textbf{tests/test\_models.py}: este archivo contiene los tests de los modelos
        de la aplicación. Principalmente testea que las operaciones de guardado de distintos
        modelos funcionen adecuadamente.
        \item \textbf{tests/test\_views.py}: este archivo contiene los tests de las vistas
        de la aplicación, testea todas las vistas diseñadas para listar, añadir, modificar o
        eliminar objetos de la base de datos.
        \item \textbf{tests/test\_forms.py}: este archivo contiene los tests de los formularios
        de la aplicación. Principalmente comprueba que los formularios sean válidos o no
        al introducir determinados datos de entrada.
        \item \textbf{tests/test\_api.py}: este archivo contiene los tests de la API de la
        aplicación. Comprueba que las principales operaciones de listar, añadir, modificar y
        eliminar se ejecuten correctamente sobre los modelos.
    \end{itemize}

Gracias al descubrimiento de pruebas (\textbf{\textit{Test discovery}}) basado en el módulo
de unittest \cite{test-discovery}, se descubrirán tests que se encuentren en cualquier nombre
de archivo que siga la expresión regular \textbf{test*.py}. Además, tambien podemos indicar
la ejecución de tests concretos mediante la adición de \textbf{etiquetas de test}
(\textit{test labels}). Por ejemplo, supongamos que queremos ejecutar un determinado método
de test llamado \textbf{test\_list\_excavations\_GET}. Para ello, podemos indicarlo de la
siguiente forma:

    \begin{enumerate}
        \item \textbf{myFindings.tests} es la ruta completa de puntos de Python hacia el
        paquete \textbf{tests}.
        \item \textbf{test\_views} indica el módulo (archivo Python) donde se quieren
        buscar los tests.
        \item \textbf{TestListingViews} indica el nombre de la \textbf{subclase de TestCase},
        ya que hereda de la clase TestCase de Django:
    
    \begin{minted}[mathescape, linenos,numbersep=5pt,bgcolor=lightgray,gobble=2,
                    frame=lines,fontsize=\footnotesize,framesep=2mm]{python}
    class TestListingViews(TestCase):
        .
        .
    \end{minted}
        \newpage \item \textbf{test\_list\_excavations\_GET} indica el método de test que se quiere
        ejecutar.
    \end{enumerate}

    \begin{figure}[H]
        \centering
        \includegraphics[scale=0.27]{imagenes/one-test.png}
        \caption{Ejecución de un método de test}
        \label{fig:one-test}
    \end{figure}

Al terminar la realización de test (por ahora) en este \textit{milestone} se han realizado
un total de \textbf{142 tests}, intentando testear la máxima cantidad de código posible.
La ejecución de los mismos se encuentra en la siguiente imagen:

    \begin{figure}[H]
        \centering
        \includegraphics[scale=0.30]{imagenes/all-tests.png}
        \caption{Ejecución de todos los tests}
        \label{fig:all-tests}
    \end{figure}

\subsection{Integración continua}
En este \textit{milestone} del proyecto se va a explicar en qué consiste la integración
continua y cómo se ha llevado a cabo en este proyecto. Antes de nada, vamos a explicar en
qué consiste la integración continua \cite{continuous-integration}:

    \begin{itemize}
        \item La \textbf{integración continua} o \textbf{CI} es una práctica de desarrollo
        del \textit{software} que nos permite controlar que en proyectos donde trabajan uno
        o varios desarrolladores el código siga funcionando adecuadamente mediante la
        automatización de pruebas de test, compilado, ejecución, etc.
    \end{itemize}

Imaginemos que estamos trabajando colaborativamente en un proyecto y hasta el momento todo
funcionaba correctamente. Ahora, un compañero que está trabajando en una mejora, añade su
código a la base del proyecto. Esta nueva mejora hace cambiar el comportamiento habitual del
proyecto, haciendo que se produzcan resultados incorrectos. Este error puede venir causado
por la falta de ejecución de tests antes de añadir el código, error que se podría haber
evitado si antes de añadir dicho código al proyecto base se hubiesen ejecutado los tests
automáticamente. Este tipo de \textbf{pruebas automatizadas} es lo que se conoce como
integración continua.\\

\newpage Entre los principales requisitos que debe tener el sistema de integración continua que
usemos se encuentran:

    \begin{itemize}
        \item Que sea sencillo de configurar, tanto para la ejecución de tests como para
        cualquier otra tarea.
        \item Que no requiera introducir tarjeta de crédito o pagar por mensualidad, es
        decir, que sea gratuito.
        \item Que sea fácil de integrar con Github, es decir, que permita ver fácilmente el
        resultado de la integración continua ejecutada.
    \end{itemize}

En la actualidad, existen numerosos sistemas de CI, entre los que podemos encontrar:

    \begin{itemize}
        \item \textbf{Travis CI} \cite{travis-ci}: si atendemos a la facilidad de uso y lo
        estándar que es el sistema, quizás este sea el más recomendado de usar, sin embargo,
        requiere introducir tarjeta de crédito, por lo que lo hemos descartado como opción.
        \item \textbf{Jenkins} \cite{jenkins}: este sistema de CI probablemente sea el más
        popular en la actualidad. Sin embargo, no es solo un sistema de CI, por lo
        que muchas de sus características no las usaríamos.
        \item \textbf{GitHub Actions} \cite{github-actions}: este sistema de CI viene
        proporcionado por Github y tiene la ventaja de poder usar otras Github Actions ya
        implementadas, además de que permite automatizar, personalizar y ejecutar flujos de
        trabajo (explicados más adelante) directamente desde el repositorio de Github.
        \item \textbf{Circle CI} \cite{circle-ci}: este sistema de CI es muy completo y
        sencillo de utilizar. Además, permite visualizar los resultados de las pruebas de la
        integración continua habilitando el Github Checks.
    \end{itemize}

    Mencionados los sistemas de CI más relevantes (hay muchos más), hemos decidido usar las
    Github Actions de Github, ya que permiten una configuración sencilla, es un servicio
    gratuito, es la herramienta con la que más familiarizados estamos (aunque se podría haber
    escogido Circle CI sin problema), es muy potente y, además, como es obvio, permite ver los
    resultados de CI directamente en la interfaz de esta.

\subsubsection{Flujos de trabajo}
En este apartado, explicaremos qué son los \textbf{flujos de trabajo o \textit{workflows}} y
cuáles hemos añadido a nuestro proyecto.\\

Un flujo de trabajo es un proceso automatizado que ejecutará uno o más \textbf{trabajos}
(\textit{job}), siendo un \textit{job} una tarea que se ejecuta en un entorno determinado y
donde existen una serie de pasos (\textit{steps}). Dichos flujos de trabajo se definen en
archivos que siguen el formato YAML (\textit{Yet Another Markup Language}), un formato de
serialización de datos de alto nivel (comprensible por humanos).\\

Estos \textit{workflows} se definen en la carpeta \textbf{.github/workflows} en el directorio
raíz del repositorio. Puede haber tantos \textit{workflows} como se desee, normalmente uno
por archivo. Cada \textit{workflow} debe tener los siguientes tres componentes:

    \begin{enumerate}
        \item El evento que hace que se ejecute el \textit{workflow} (\textbf{\textit{trigger}}).
        \item Uno o más trabajos (\textbf{jobs}), cada uno de los cuales estará ejecutado en
        un entorno a elegir (máquina virtual, contenedor, etc.) y ejecutará una serie de
        pasos (\textbf{\textit{steps}}).
        \item Cada \textit{step} podrá ejecutar un script que hayamos definido nosotros
        mismos, un comando del entorno donde estemos ejecutando el \textit{job}, o bien usar
        una Github Action predefinida que podamos encontrar en
        \href{https://github.com/marketplace?type=actions}{GitHub Marketplace}.
    \end{enumerate}

En nuestro proyecto, hemos definido tres flujos de trabajo o \textit{workflows}, llamados
de la siguiente forma:

    \begin{enumerate}
        \item \textbf{\href{https://github.com/alexespana/TFG/actions/workflows/docs.yml}
        {Build LaTeX documentation}}: este flujo de trabajo se encargará de comprobar que
        la documentación del proyecto pueda construirse correctamente. Procedemos a
        explicar sus partes principales:
            \begin{enumerate}
                \item \textbf{\textit{Trigger}}: este flujo de trabajo se ejecutará cuando
                se haga \textit{push}\footnote{Subida de cambios desde el repositorio local
                al remoto, normalmente con el comando \textbf{git push} o similar.} al
                repositorio, siempre y cuando los archivos modificados sean el propio
                archivo donde se define el \textit{workflow} (\textbf{docs.yml}) o cualquier
                archivo latex de la documentación.
                \item \textbf{\textit{Job}}: existe un único \textit{job} llamado
                \textbf{build-latex} que se ejecutará en la última versión de ubuntu
                (\textbf{ubuntu-latest}) y que tendrá una serie de \textit{steps} que se
                encargarán de compilar el código latex.
                \item \textbf{\textit{Steps}}: el \textit{job} build-latex se compone de dos
                pasos:
                    \begin{enumerate}
                        \item \textbf{Checkout}: acción muy típica en Github Actions. Se baja
                        todos los archivos del repositorio para poder trabajar con ellos. En
                        él se ha usado una Github Action predefinida llamada
                        \href{https://github.com/marketplace/actions/checkout}{Checkout}.
                        \item \textbf{Compile LaTeX document}: este paso compila todos los
                        archivos latex y construye un pdf de salida. En él también se ha
                        usado una Github Action predefinida llamada
                        \href{https://github.com/marketplace/actions/github-action-for-latex}
                        {Github Action for LaTeX}
                    \end{enumerate}
            \end{enumerate}

        \item \textbf{\href{https://github.com/alexespana/TFG/actions/workflows/build.yml}
        {Build images}}: como ya mencionamos en secciones anteriores, nosotros hemos decidido
        ejecutar nuestra aplicación utilizando Docker y Docker Compose, por lo que este flujo
        de trabajo se encargará de comprobar que las imágenes se creen correctamente. Entre
        sus principales partes tenemos:
            \begin{enumerate}
                \item \textbf{\textit{Trigger}}: este flujo de trabajo se ejecutará cuando
                se haga \textit{push} al repositorio, siempre y cuando los archivos
                modificados sean el propio archivo donde se define el \textit{workflow}
                (\textbf{build.yml}) o cualquier archivo que se encuentre en el primer nivel
                de la carpeta \textbf{code}, es decir, los archivos
                \textit{docker-compose.yml, Dockerfile y requirements.txt}.
                \item \textbf{\textit{Job}}: existe un único \textit{job} llamado
                \textbf{build-images} que se ejecutará en la última versión de ubuntu
                (\textbf{ubuntu-latest}) y que tendrá una serie de \textit{steps} que se
                encargarán de construir las imágenes.
                \item \textbf{\textit{Steps}}: el \textit{job} build-images se compone
                únicamente de dos pasos:
                    \begin{enumerate}
                        \item \textbf{Checkout}: es exactamente el mismo paso descrito para
                        el \textit{workflow} anterior.
                        \item \textbf{Build images}: en este paso se construyen las
                        imágenes. Para ello, desde la carpeta code se ejecuta el comando
                        \textbf{docker-compose build} para construir las imágenes.
                    \end{enumerate}
            \end{enumerate}

        \item \textbf{\href{https://github.com/alexespana/TFG/actions/workflows/tests.yml}
        {Tests}}: este flujo de trabajo es algo más complejo que los anteriores y se encargará
        de ejecutar automáticamente las pruebas de tests. Procedamos a explicar sus componentes:
            \begin{enumerate}
                \item \textbf{\textit{Trigger}}: al igual que en \textit{workflows}
                anteriores, este flujo se ejecutará cuando se haga \textit{push} al
                repositorio, siempre y cuando los archivos modificados sean el propio
                archivo donde se define el \textit{workflow} (\textbf{tests.yml}) o
                cualquier archivo Python del proyecto de Django.
                \item \textbf{\textit{Job}}: en este caso también hay un único \textit{job},
                llamado \textbf{run-tests} y que se ejecutará en la última versión de
                ubuntu (\textbf{ubuntu-latest}).
                \item \textbf{\textit{Services}}: dado que debemos ejecutar los tests
                utilizando un servicio para la base de datos, ha sido necesario definir
                dentro del ejecutor del flujo (ubuntu-latest) un servicio de Postgres. De
                esta forma, podremos crear la base de datos para test.              
                \item \textbf{\textit{Steps}}: este \textit{job} tiene un total de cinco
                pasos, que son los siguientes:
                    \begin{enumerate}
                        \item \textbf{Checkout}: es exactamente el mismo paso descrito para
                        el \textit{workflow} anterior.
                        \item \textbf{Set up Python}: en este paso inicializamos el entorno
                        con una \textbf{versión de Python}, en concreto con la versión 3.10.
                        Para ello, se ha utilizado la Github Action predefinida
                        \href{https://github.com/marketplace/actions/setup-python}{Setup
                        Python}.
                        \item \textbf{Install dependencies}: instalación de las dependencias
                        necesarias para que el proyecto funcione. Dichas dependencias se
                        encuentran en el archivo \textbf{requirements.txt}.
                        \item \textbf{Run tests}: ejecución de los tests. Para ello, se han
                        tenido que definir varias variables de entorno. Estas variables de
                        entorno se almacenan en los \textbf{\textit{secrets}} de Github,
                        variables secretas que se definen en el repositorio y que luego son
                        accesibles desde el entorno de los \textit{workflows}.\\
                        
                        Dicho esto, cabe destacar que para la ejecución de los tests, se ha
                        utilizado la herramienta \href{https://pypi.org/project/coverage/}
                        {Coverage}, que mide la \textbf{cobertura del código}, es decir,
                        determina qué porcentaje de líneas de código del total del proyecto
                        se han ejecutado durante los tests, además de generar un informe que
                        será utilizado por el paso siguiente. Por lo tanto, cuanto más
                        elevado sea ese porcentaje, mayor muestra de código de calidad
                        tendremos. Este sería el resultado de la ejecución:

                                \begin{figure}[H]
                                    \centering
                                    \includegraphics[scale=0.41]{imagenes/codecov-report.png}
                                    \caption{Informe de Codecov}
                                    \label{fig:codecov-report}
                                \end{figure}
                        
                        Como vemos, se ha testeado el 97\% del código por ahora, lo
                        cual es un resultado bastante bueno y, además, se ha escrito el
                        informe en el archivo \textbf{coverage.xml}.
                        
                        \item \textbf{Codecov}: este último paso utiliza una Github Action
                        predefinida llamada
                        \href{https://github.com/marketplace/actions/codecov}{Codecov GitHub
                        Action}, que se encarga de subir los resultados del informe del paso
                        anterior a Codecov web, que nos servirá posteriormente para la
                        generación de una \textbf{insignia de estado}, de las que hablaremos
                        en el siguiente apartado, para el porcentaje de código cubierto.
                    \end{enumerate}
            \end{enumerate}
    \end{enumerate}

\newpage Estos son los flujos de trabajo o \textit{workflows} que se ejecutarán automáticamente en
nuestro proyecto cada vez que se produzca uno de los eventos descritos.

\subsubsection{Insignias de estado}
Una buena práctica en un proyecto \textit{software} donde se practique integración continua,
es la inclusión de \textbf{insignias de estado}, o \textbf{\textit{badges}}. Antes de nada,
vamos a explicar qué es una insignia de estado: una insignia de estado es simplemente un
elemento gráfico que indica si un flujo de trabajo falla o pasa actualmente. Con esto en
mente, nosotros podríamos incluir cuatro insignias de estado: \textbf{una por cada flujo de
trabajo de CI} y otra adicional mostrando el \textbf{porcentaje de código testeado}.\\

Normalmente dichas insignias se incluyen en la página principal del proyecto, es decir, en
el \textbf{README.md}, que será lo primero que veamos al entrar, dándonos una buena señal
de calidad del código del mismo. Dicho esto, el aspecto de la página inicial de nuestro
repositorio sería el siguiente:

    \begin{figure}[H]
        \centering
        \includegraphics[scale=0.27]{imagenes/badge-status.png}
        \caption{Insignias de estado}
        \label{fig:badge-status}
    \end{figure}

Como vemos, todas ellas indican que las pruebas automatizadas de integración continua han
pasado con éxito y, además, tenemos el porcentaje de Codecov añadido, para el cual se ha
obtenido el \textit{badge} desde Codecov web. Adicionalmente, se ha añadido el
\textit{badge} de la \textbf{licencia} de código que estamos usando, \textbf{GNU GPLv3}
\cite{gplv3}.

\newpage \subsection{API REST}
En este \textit{milestone} del desarrollo \textit{software}, vamos a explicar en qué
consiste una API, los distintos tipos que nos podemos encontrar, por qué son necesarias y,
sobre todo, cómo la hemos implementado en nuestra aplicación web.\\

Una \textbf{API \cite{api} (\textit{Application Programming Interface} o Interfaz de
programación de aplicaciones)} es un conjunto de protocolos y estándares para desarrollar e
integrar el \textit{software} de las aplicaciones, es decir, establecen cómo se han de
comunicar dos aplicaciones e intercambiar datos en internet mediante un conjunto de reglas.\\ \\

La creación de una API permite que los servicios o recursos que utiliza una aplicación
puedan ser accedidos desde cualquier otro servicio o aplicación, sin necesidad de
conocer cómo están implementados. Según el tipo de interfaz o especificación de protocolo
que use la API, podemos distinguir dos tipos:

    \begin{itemize}
        \item \textbf{SOAP}: este tipo de API, conocida como \textbf{Protocolo de Acceso a
        Objetos Simples}, surgió como consecuencia del creciente uso de las APIs y para
        permitir una estandarización en el intercambio de la información. Utilizan XML
        como lenguaje de programación de intercambio de datos y, pueden usar HTTP,
        FTP, SMTP, etc. como protocolo de comunicación. Con este tipo de protocolo, la
        comunicación entre aplicaciones que se encuentren en entornos distintos o que estén
        escritas en distintos lenguajes se hace más sencilla. En la actualidad, su uso es
        reducido, ya que normalmente se usan para transacciones complejas que requieren
        alta seguridad, como pasarelas de pago, ERPS\footnote{\textbf{Sistemas de
        planificación de recursos empresariales}: \textit{software} de gestión empresarial
        compuesto por módulos que gestionan y automatizan tareas internas de la empresa.},
        etc.

        \item \textbf{REST}: este tipo de API, conocida como \textbf{\textit{Representational
        State Transfer} o Transferencia de Estado Representacional}, es una interfaz simple
        que solo usa HTTP y JSON o XML en la respuesta. Una de sus principales
        características es que se basa en una sintaxis universal para el acceso a los
        recursos, utilizando las \textbf{\textit{Uniform Resource Identifier} (URI)}, que
        son una secuencia de caracteres que identifican un recurso lógico o físico en una
        aplicación.\\
        
        Este tipo de API, en su versión más extendida (es la que usamos en nuestro proyecto)
        pasa a considerarse \textbf{RESTful}, con la peculiaridad de usar los verbos de
        \href{https://developer.mozilla.org/es/docs/Web/HTTP/Methods}{HTTP} para las
        llamadas desde el cliente (aplicación Android) al servidor, asociándolos a
        operaciones \textbf{CRUD} (\textit{Create, Read, Update, Delete}) de los recursos.
        En concreto, las API se consideran RESTful cuando siguen los siguientes cuatro
        principios:

            \begin{enumerate}
                \item \textbf{Usar explícitamente los verbos HTTP}: las llamadas a la API
                deben ser usando los verbos o métodos HTTP, teniendo los siguientes
                (asociándolos a operaciones CRUD):
                    
                    \begin{itemize}
                        \item \textbf{GET}: para obtener un recurso (\textit{Read}).
                        \item \textbf{POST}: para crear un recurso (\textit{Create}).
                        \item \textbf{PUT}: para actualizar un recurso (\textit{Update}).
                        \item \textbf{PATCH}: para actualizar parcialmente un
                        recurso (\textit{Update}).
                        \item \textbf{DELETE}: para eliminar un recurso (\textit{Delete}).
                    \end{itemize}

                \item \textbf{Ser sin estado (\textit{stateless})}: que el resultado de las
                llamadas no dependa de otras llamadas anteriores, es decir, que sea
                \textbf{idempotente}.
                \item \textbf{Usar URI con estilo \textit{path}}: que las URI sigan un formato
                estándar, es decir, que sean legibles por humanos y pueda identificarse
                claramente el recurso que se solicita. Por ejemplo, si solicitamos una
                excavación, que la URI no sea así: \textbf{/info\_excavacion?id=1}, y que
                sea algo así: \textbf{/excavaciones/1}. Estos \textit{paths} son los
                llamados \textbf{\textit{endpoints}}.
                \item \textbf{Devolver en la respuesta JSON o XML}: como hemos mencionado
                anteriormente, las respuestas deben ser en formato XML o JSON,
                devolviendo el \href{https://developer.mozilla.org/es/docs/Web/HTTP/Status}
                {\textit{status code}} correspondiente, es decir, el código de estado HTTP
                que indica cuál es el resultado de la petición.
            \end{enumerate}
    \end{itemize}

\subsubsection{Django REST Framework}
En esta sección explicaremos con detalle  en qué consiste \textbf{Django REST Framework}
\cite{djangorestframework} y cómo se ha utilizado en nuestro proyecto para la
implementación de la \textbf{API RESTful}.\\

Django de por sí no trae un mecanismo para implementar APIs web, por lo que se ha tenido
que añadir a las dependencias y, por tanto, añadir como aplicación instalada al proyecto,
Django REST Framework. Esta aplicación nos proporciona todas las funcionalidades
necesarias para la implementación de la API de nuestro proyecto. Funcionalidades como:

    \begin{itemize}
        \item \textbf{Autenticación}: para que la API sea accesible solo por usuarios
        autenticados.
        \item \textbf{Autorización}: para que los usuarios autenticados puedan realizar
        operaciones CRUD sobre los recursos.
        \item \textbf{Serialización}: para que los datos devueltos por la API sean
        representados en formato JSON o XML.
        \item \textbf{Deserialización}: para que los datos recibidos por la API sean
        interpretados en formato JSON o XML.
        \item \textbf{Cache}: para que la API no sea consultada varias veces para la
        solicitud de un mismo recurso.
        \item \textbf{\textit{Routing}}: para que se pueda acceder a la API  a través de
        una URI.
        \item \textbf{Paginación}: para que la API devuelva páginas de resultados.
    \end{itemize}

Como vemos, entre ellas se encuentran algunos de los requisitos necesarios para poder
considerar una API como RESTful, como por ejemplo, que permita almacenar información en
la memoria caché o que las respuestas sean en JSON o XML.\\

Para la creación de cualquier ruta en la API que sea funcional, son necesarios los
siguientes elementos:

    \begin{itemize}
        \item \textbf{\textit{Router}}: es una clase ya incluida en el módulo de Django REST
        Framework que nos permitirá definir la ruta correspondiente al
        \textbf{\textit{endpoint}} que queremos implementar. Por ejemplo, en el caso de las
        excavaciones se haría del siguiente modo:
    
    \begin{minted}[mathescape, linenos,numbersep=5pt,bgcolor=lightgray,gobble=2,
                    frame=lines,fontsize=\footnotesize,framesep=2mm]{python}
    from rest_framework import routers
    from .views import ExcavationViewSet
        .
        .
    # API endpoints
    router = routers.DefaultRouter()
    router.register('excavation', ExcavationViewSet)
        .
        .
    \end{minted}

        \item \textbf{\textit{Serializer}}: es una clase que hereda de
        \textbf{ModelSerializer} y que se encargará de serializar automáticamente los datos
        correspondientes a un modelo dado, es decir, poder transformarlo a formato JSON o
        XML, además de generar los validadores correspondientes para el serializador, siendo
        capaz de crear hasta validadores de claves compuestas (\textbf{unique\_together}).
        Gracias a ellos podremos controlar la salida de las respuestas. Igualmente, para
        las excavaciones tendríamos la siguiente implementación:
    
    \newpage \begin{minted}[mathescape, linenos,numbersep=5pt,bgcolor=lightgray,gobble=2,
                    frame=lines,fontsize=\footnotesize,framesep=2mm]{python}
    from rest_framework import serializers
    from .models import Excavation
        .
        .
    class ExcavationSerializer(serializers.ModelSerializer):
      class Meta:
          model = Excavation
          fields = '__all__'
        .
        .
    \end{minted}

        \item \textbf{\textit{Viewset}}: es una clase que hereda de \textbf{ModelViewSet} y
        que será la vista asociada a una URI concreta. Además de esto, cabe mencionar que
        la clase ModelViewSet hereda de la clase \textbf{GenericAPIView}, por lo que
        incluye ya implementadas acciones como listar, recuperar, actualizar, actualizar
        parcialmente y eliminar, teniendo solo que definir al menos dos atributos en la
        clase que son el \textbf{queryset} y el \textbf{serializer}. Por ejemplo, para las
        excavaciones, tendríamos la siguiente implementación:
    
    \begin{minted}[mathescape, linenos,numbersep=5pt,bgcolor=lightgray,gobble=2,
                    frame=lines,fontsize=\footnotesize,framesep=2mm]{python}
    from .serializers import ExcavationSerializer
    from .models import Excavation
        .
        .
    # API REST
    class ExcavationViewSet(viewsets.ModelViewSet):
        queryset = Excavation.objects.all()
        serializer_class = ExcavationSerializer
        .
        .
    \end{minted}
        
        Esta vista utilizará el serializador anteriormente mencionado para poder crear
        un formulario acorde a los campos del modelo en cuestión, en este caso de la
        excavación.
    \end{itemize}

Teniendo esto en cuenta, nuestra aplicación tendrá los siguientes \textbf{\textit{endpoints}}:

\begin{longtable}[H]{|l|l|l|}
    \hline
    \textbf{Método} & \textbf{\textit{EndPoint}} & \textbf{Descripción} \\
    \hline
    \endfirsthead
   
    \hline
    \multicolumn{3}{|c|}{Continuación de la tabla \ref{tab:endpoints}}\\
    \hline
    \textbf{Método} & \textbf{\textit{EndPoint}} & \textbf{Descripción} \\
    \hline
    \hline
    \endhead
   
    \hline\hline
    \multicolumn{3}{|l|}{\textbf{Excavaciones}} \\
    \hline
    GET & api/excavation & Lista de excavaciones \\
    GET & api/excavation/\{pk\} & Recupera una excavación\\
    POST & api/excavation & Crea una excavación \\
    PUT & api/excavation/\{pk\} & Actualiza una excavación \\
    PATCH & api/excavation/\{pk\} & Actualiza parcialmente una \\
    &  & excavación \\
    DELETE & api/excavation/\{pk\} & Elimina una excavación \\
    \hline\hline
    \multicolumn{3}{|l|}{\textbf{Fotografías}} \\
    \hline
    GET & api/photo & Lista de fotografías \\
    GET & api/photo/\{pk\} & Recupera una fotografía \\
    POST & api/photo & Crea una fotografía \\
    PUT & api/photo/\{pk\} & Actualiza una fotografía \\
    PATCH & api/photo/\{pk\} & Actualiza parcialmente una \\
    &  & fotografía \\
    DELETE & api/photo/\{pk\} & Elimina una fotografía \\
    \hline\hline
    \multicolumn{3}{|l|}{\textbf{Inclusiones}} \\
    \hline
    GET & api/inclusion & Lista de inclusiones \\
    GET & api/inclusion/\{pk\} & Recupera una inclusión \\
    POST & api/inclusion & Crea una inclusión \\
    PUT & api/inclusion/\{pk\} & Actualiza una inclusión\\
    PATCH & api/inclusion/\{pk\} & Actualiza parcialmente una \\
    &  & inclusión \\
    DELETE & api/inclusion/\{pk\} & Elimina una inclusión \\
    \hline\hline
    \multicolumn{3}{|l|}{\textbf{Unidades sedimentarias}} \\
    \hline
    GET & api/sedimentaryue & Lista de unidades sedimentarias \\
    GET & api/sedimentaryue/\{codigo\} & Recupera una unidad sedimentaria \\
    POST & api/sedimentaryue & Crea una unidad sedimentaria \\
    PUT & api/sedimentaryue/\{codigo\} & Actualiza una unidad sedimentaria \\
    PATCH & api/sedimentaryue/\{codigo\} & Actualiza parcialmente una \\
    &  & unidad sedimentaria \\
    DELETE & api/sedimentaryue/\{codigo\} & Elimina una unidad sedimentaria \\
    \hline\hline
    \multicolumn{3}{|l|}{\textbf{Unidades construidas}} \\
    \hline
    GET & api/builtue & Lista de unidades construidas \\
    GET & api/builtue/\{codigo\} & Recupera una unidad construida \\
    POST & api/builtue & Crea una unidad construida \\
    PUT & api/builtue/\{codigo\} & Actualiza una unidad construida \\
    PATCH & api/builtue/\{codigo\} & Actualiza parcialmente una \\
    &  & unidad construida \\
    DELETE & api/builtue/\{codigo\} & Elimina una unidad construida \\
    \hline\hline
    \multicolumn{3}{|l|}{\textbf{Materiales sedimentarios}} \\
    \hline
    GET & api/sedimentarymaterial & Lista de materiales sedimentarios \\
    GET & api/sedimentarymaterial/\{pk\} & Recupera un material sedimentario \\
    POST & api/sedimentarymaterial & Crea un material sedimentario \\
    PUT & api/sedimentarymaterial/\{pk\} & Actualiza un material sedimentario \\
    PATCH & api/sedimentarymaterial/\{pk\} & Actualiza parcialmente un \\
    &  & material sedimentario \\
    DELETE & api/sedimentarymaterial/\{pk\} & Elimina un material sedimentario \\
    \hline\hline
    \newpage \multicolumn{3}{|l|}{\textbf{Materiales construidos}} \\
    \hline
    GET & api/builtmaterial & Lista de materiales construidos \\
    GET & api/builtmaterial/\{pk\} & Recupera un material construido \\
    POST & api/builtmaterial & Crea un material construido \\
    PUT & api/builtmaterial/\{pk\} & Actualiza un material construido \\
    PATCH & api/builtmaterial/\{pk\} & Actualiza parcialmente un \\
    &  & material construido \\
    DELETE & api/builtmaterial/\{pk\} & Elimina un material construido \\
    \hline\hline
    \multicolumn{3}{|l|}{\textbf{Hechos}} \\
    \hline
    GET & api/fact & Lista de hechos \\
    GET & api/fact/\{pk\} & Recupera un hecho \\
    POST & api/fact & Crea un hecho \\
    PUT & api/fact/\{pk\} & Actualiza un hecho \\
    PATCH & api/fact/\{pk\} & Actualiza parcialmente \\
    &  & un hecho \\
    DELETE & api/fact/\{pk\} & Elimina un hecho \\
    \hline\hline
    \multicolumn{3}{|l|}{\textbf{Estancias}} \\
    \hline
    GET & api/room & Lista de estancias \\
    GET & api/room/\{pk\} & Recupera una estancia \\
    POST & api/room & Crea una estancia \\
    PUT & api/room/\{pk\} & Actualiza una estancia \\
    PATCH & api/room/\{pk\} & Actualiza parcialmente \\
    &  & una estancia \\
    DELETE & api/room/\{pk\} & Elimina una estancia \\
    \hline

    \caption{Endpoints de la API}
    \label{tab:endpoints}
\end{longtable}

Como podemos observar, existen bastantes \textit{endpoints} para la API. Cabe nombrar que
los términos que aparecen entre corchetes serían los parámetros que reciben los
\textit{endpoints}, donde \textbf{pk} (\textit{primary key} o clave primaria) es el id
interno que se genera automáticamente en la base de datos y consiste en un número entero y,
el \textbf{codigo} para las unidades estratigráficas es el identificador formado por la
excavación a la que pertenece la unidad y el número de orden de esta. Por ejemplo, si
la unidad pertenece a la excavación \textbf{1} y es la segunda unidad de la excavación, el
código sería \textbf{001002} y el \textit{endpoint} para obtener dicha unidad estratigráfica
(supongamos que es una unidad construida) sería:

            \begin{center} \textbf{api/builtue/001002} \end{center}

\newpage \subsubsection{Autenticación}
Otro de los puntos a tener en cuenta es la autenticación en la API, ya que no cualquier
usuario puede tener acceso a ella y realizar cualquier acción sobre los recursos de la
aplicación. Para ello, se debe elegir un sistema de autenticación adecuado. Dado que
nuestro proyecto es un servidor web al que una aplicación móvil debe hacer peticiones,
el esquema \textbf{Autenticación mediante \textit{Token}} es el más apropiado. Para usar
este esquema de \textbf{TokenAuthentication}, se necesita incluir
\textbf{rest\_framework.authtoken} en la configuración de aplicaciones instaladas de la
aplicación.\\

Teniendo en cuenta lo anteriormente mencionado, los clientes podrán autenticar a los usuarios
pasando en el cuerpo de la petición un \textit{token} vinculado a un usuario determinado.
Para ello, el \textit{token} deberá estar incluido en la cabecera HTTP de autorización. Por
ejemplo:

\begin{center}
    \textbf{Authorization: Token 9944b09199c62bcf9418ad846dd0e4bbdfc6ee4b}
\end{center}

A continuación, vamos a describir el procedimiento de utilización de la API, tanto desde el
punto de vista gráfico mediante la \textbf{interfaz web} como desde la simulación del envío
de peticiones a través de un \textbf{cliente móvil}.\\

Esta sería la interfaz gráfica de la API, donde tenemos una pestaña de
\textbf{\textit{login}} para autenticarse en ella, las distintas opciones (OPTIONS) y
métodos HTTP (GET, etc.) y, finalmente, las distintas rutas definidas en la API para el
manejo de los recursos del servidor, junto a las cabeceras HTTP que se usan en cada petición.

        \begin{figure}[H]
            \centering
            \includegraphics[scale=0.30]{imagenes/root-api.png}
            \caption{\textit{Home} de la API}
            \label{fig:root-api}
        \end{figure}

\newpage Si un usuario no autenticado intentase acceder a cualquier enlace de la misma, obtendría el
siguiente mensaje, que indica que no se proveyeron las credenciales del usuario, ya que al
añadir el \textit{login} para la API, es necesario que los usuarios estén autenticados para
poder usarla.

        \begin{figure}[H]
            \centering
            \includegraphics[scale=0.30]{imagenes/unauthorized.png}
            \caption{API web: no autorizado (unauthorized)}
            \label{fig:unauthorized}
        \end{figure}

Una vez ingresadas nuestras credenciales en el inicio de sesión (en este caso hemos creado
un usuario ficticio que se llama \textbf{Alex} y tiene de constraseña \textbf{inventado1234}),
podríamos ver la lista con las excavaciones disponibles en la aplicación.

        \begin{figure}[H]
            \centering
            \includegraphics[scale=0.30]{imagenes/list-excavations.png}
            \caption{Lista de excavaciones}
            \label{fig:list-excavations}
        \end{figure}

Ahora vamos a proceder a realizar una sencilla simulación del flujo de acciones que tendría
que realizar un cliente para poder utilizar la API. Para ello, hemos utilizado
\href{https://www.postman.com/}{POSTMAN}, una herramienta que nos permite realizar
peticiones a través de una interfaz muy simple y fácil de usar.\\

Lo primero de todo, sería obtener el \textbf{\textit{token} de autenticación} para poder
autenticarse en la aplicación. Para ello, haría una petición \textbf{POST} a una ruta
concreta, en este caso \textbf{api-token-auth/}, enviando en el cuerpo de la petición el
\textbf{nombre} y \textbf{\textit{password}} del usuario (inicio de sesión):

        \begin{figure}[H]
            \centering
            \includegraphics[scale=0.25]{imagenes/get-token.png}
            \caption{Obtención del \textit{token} de autenticación}
            \label{fig:get-token}
        \end{figure}

Como vemos, el servidor web ha devuelto un \textit{token} vinculado al usuario. Dicho
\textit{token} será almacenado para realizar peticiones a la API, enviando el \textit{token}
en la cabecera de autorización de la petición. Si por ejemplo intentamos obtener todas las
excavaciones disponibles sin mandar el \textit{token} de autenticación, obtendremos el
siguiente mensaje, que es el mismo que obteníamos anteriormente en la interfaz web:

    \begin{figure}[H]
        \centering
        \includegraphics[scale=0.45]{imagenes/unauthorized2.png}
        \caption{Petición a la API: no autorizado (unauthorized)}
        \label{fig:unauthorized2}
    \end{figure}

Esto se debe a que el cliente no ha enviado el \textit{token} obtenido anteriormente en la
cabecera de autorización de la petición. Para ello, deberá hacerlo de la siguiente
forma:

    \begin{figure}[H]
        \centering
        \includegraphics[scale=0.38]{imagenes/token-auth.png}
        \caption{Autenticación mediante \textit{token}}
        \label{fig:token-auth}
    \end{figure}

Como vemos, hemos obtenido la correspondiente información en formato JSON sobre las
excavaciones disponibles.\\

Finalmente, podríamos hacernos una pregunta, \textbf{¿y los permisos de los usuarios en la
API, se mantienen igual que los otorgados en la aplicación web?} La respuesta es sí, siempre
y cuando se haga la configuración correspondiente. Para ello, debemos indicar que se usen
los mismos permisos que se han otorgado en los modelos de la aplicación web. Es decir, si
tenemos un usuario en la aplicación al que solo le hemos dado permiso para añadir excavaciones
y no modificarlas, en la API debe ser exactamente igual. Con la siguiente configuración en
\textbf{settings.py} podremos indicar que se usen los mismos permisos:

    
    \begin{minted}[mathescape, linenos,numbersep=5pt,bgcolor=lightgray,gobble=2,
                    frame=lines,fontsize=\footnotesize,framesep=2mm]{python}
    REST_FRAMEWORK = {
        .
        .
        .
        'DEFAULT_PERMISSION_CLASSES': [
            'rest_framework.permissions.DjangoModelPermissions',
        ]
    }
    \end{minted}

Veamos si funciona correctamente. Primero enviamos una petición POST a la ruta de la API
\textbf{api/excavation/} para añadir una excavación, pasando en el cuerpo de la misma
todos los datos necesarios:

        \begin{figure}[H]
            \centering
            \includegraphics[scale=0.40]{imagenes/post-excavation.png}
            \caption{Añadir excavación}
            \label{fig:post-excavation}
        \end{figure}

Ahora si intentásemos modificar la misma excavación,tendríamos que realizar una petición
\textbf{PUT} o \textbf{PATCH} a la ruta \textbf{api/excavation/} con el id de la excavación
que queremos modificar, es decir, \textbf{api/excavation/1/}, pasando en el cuerpo de la
petición los datos que queremos modificar:

        \begin{figure}[H]
            \centering
            \includegraphics[scale=0.40]{imagenes/put-excavation.png}
            \caption{Modificar excavación}
            \label{fig:put-excavation}
        \end{figure}

Como vemos, no nos ha permitido modificar la excavación, lo cuál es correcto, ya que no
tenemos permisos para modificar excavaciones.

\subsection{Sistema de \textit{Log}}
En este \textit{milestone} del desarrollo \textit{software} nos centraremos en explicar qué
es un Sistema de \textit{Log} y cómo hemos llevado a cabo su implementación en nuestra
aplicación. \\

Un \textbf{Sistema de \textit{Log}} \cite{log-system} es una herramienta que nos permite
registrar los principales eventos que suceden en nuestra aplicación, desde operaciones
relacionadas con la base de datos hasta errores que se producen en el sistema. Normalmente,
un registro en el Sistema de \textit{Log} se corresponde con una cadena de texto, lo que de
forma técnica se denomina \textbf{registro de \textit{log}} (\textbf{\textit{log entry}}).
Estos registros de \textit{log} se suelen almacenar en ficheros de texto especiales (con
extensión \textbf{.log}), pero también se pueden almacenar en bases de datos o imprimir
directamente a través de una terminal o consola.\\

En ocasiones, al construir aplicaciones, este punto se olvida o no se implementa
adecuadamente, lo que hace que ante un error en el sistema o ante una acción extraña, sea
muy complicado averiguar la \textbf{traza}\footnote{\textbf{Origen},
\textbf{lugar de procedencia} o \textbf{rastro} que deja el error en el sistema.} del
mismo, provocando problemas como los siguientes:

    \begin{itemize}
        \item \textbf{Imposibilidad} para encontrar el origen del error que se ha
        producido.
        \item \textbf{Formas no estandarizadas} para identificar el error.
        \item \textbf{Incremento} del tiempo de respuesta ante un error, que tendrá
        consecuencias directamente negativas en la calidad de servicio.
    \end{itemize}

Para el Sistema de \textit{Log}, Django usa y extiende el módulo \textbf{logging}
\cite{python-logging} de Python, el cual es muy extenso y carece de sentido explicar a
fondo en esta sección. Sin embargo, vamos a explicar las partes principales que son
necesarias para nuestra aplicación. Toda configuración Python para \textit{logging} consta
de cuatro partes (usaremos preferentemente los términos ingleses, ya que es lo más común al
hablar sobre \textit{logging}):

    \begin{enumerate}
        \item \textbf{\textit{Loggers} (registradores)}: es el punto de entrada inicial del
        Sistema de \textit{Log} (instancia de la clase \textbf{logging.Logger}). Cada
        \textit{logger} tiene configurado un \textbf{\textit{log level}} que indicará a
        partir de qué nivel los mensajes serán procesados. Python define los siguientes
        \textit{log levels}:

            \begin{itemize}
                \item \textbf{DEBUG}: nivel más bajo de registro, normalmente se usa para
                registrar mensajes de depuración.
                \item \textbf{INFO}: información general del sistema.
                \item \textbf{WARNING}: mensaje que indica que se ha producido un error
                que no debería ocurrir, pero que es de poca importancia.
                \item \textbf{ERROR}: información que describe un error importante que se
                ha producido.
                \item \textbf{CRITICAL}: mensaje que describe un error crítico que se
                ha producido.
            \end{itemize}

        Cada mensaje que es escrito en el \textit{logger} es un \textbf{registro de
        \textit{log}} (que hemos mencionado anteriormente). Cada registro de \textit{log}
        contiene un \textbf{nivel de \textit{log}} indicando la severidad del mensaje. Cada
        vez que un mensaje es enviado al \textit{log} se comprueba si el nivel del mensaje
        es mayor o igual que el nivel de \textit{log} del \textit{logger}, si es así, se
        escribe el mensaje en el \textit{log}.

        \item \textbf{\textit{Handlers} (manejadores)}: los manejadores determinan qué sucede con
        cada mensaje escrito en un \textit{logger}. Describen un comportamiento específico
        para el \textit{logging}, como puede ser escribir el mensaje en un fichero, en una
        pantalla, en consola, etc.

        Al igual que los \textit{loggers}, también poseen un nivel de \textit{log}
        (\textit{log level}) que determina qué mensajes de los que el \textit{logger} le
        envía serán procesados, según el criterio anteriormente descrito. Esto hace posible
        que un \textit{logger} pueda tener asociados \textbf{varios \textit{handlers}}, por
        ejemplo, uno que registre mensajes \textbf{ERROR} y \textbf{CRITICAL} en un fichero
        y otro que registre mensajes de cualquier nivel.

        \item \textbf{\textit{Filters} (filtros)}: normalmente, todo mensaje que cumpla con
        el nivel de \textit{log} establecido en el \textit{logger} será pasado del
        \textit{logger} al manejador. Sin embargo, se pueden definir filtros para añadir
        criterios adicionales para que un mensaje pase del \textit{logger} al
        \textit{handler}, como puede ser por ejemplo los que provengan de una fuente
        determinada. En nuestra aplicación web, estos no serán necesarios.

        \item \textbf{\textit{Formatters} (formateadores)}: como hemos mencionado
        anteriormente, cada registro de \textit{log} se renderiza (representa) como una
        cadena de texto. Dicha cadena de texto tendrá uno u otro formato, para lo que se
        usan los formateadores.
        
        Cada registro de \textit{log} tiene una 
        \href{https://docs.python.org/3/library/logging.html#logrecord-attributes}{serie
        de atributos}  que se podrán indicar en el formateador, de modo que la cadena de
        texto tenga dicho formato. Por ejemplo, podríamos mostrar información como el
        nivel del mensaje, la fecha y hora, el nombre del \textit{logger}, la traza del
        mensaje, el número de línea donde se produjo, etc.
    \end{enumerate}

Una vez hemos explicado brevemente las partes principales para la configuración de un
Sistema de \textit{Log}, vamos a proceder a explicar cómo lo hemos implementado en nuestra
aplicación web.

\subsubsection{Notificación a administradores}
En nuestra aplicación web, como hemos explicado en puntos anteriores, existen distintos
roles de usuario, entre los que se encuentra el administrador del sistema, que corresponde
con el usuario que ha desarrollado la web y conoce perfectamente su funcionamiento. Dicho
esto, ¿cómo podría un administrador del sistema saber si se ha producido un error de
nivel \textbf{ERROR} o \textbf{CRITICAL} en la aplicación durante su uso (sin estar al
tanto de la aplicación y de forma automática)? \\

Para esta cuestión, Django incluye un manejador muy oportuno llamado
\href{https://docs.djangoproject.com/en/4.0/ref/logging/#django.utils.log.AdminEmailHandler}
{AdminEmailHandler}, que se encarga de notificar por correo electrónico a los
administradores del sistema cuando se producen errores de nivel \textbf{ERROR} o
\textbf{CRITICAL}. \\

Para que funcione correctamente, primero debemos incorporar a nuestro archivo de
configuración \textbf{settings.py} la variable \textbf{ADMINS}, que contiene la lista de
administradores del sistema. Por cuestiones de seguridad y privacidad, hemos decidido
darle valor a esta variable a través de variables de entorno definidas en un archivo
\textbf{.env}, quedando algo así:

    
    \begin{minted}[mathescape, linenos,numbersep=5pt,bgcolor=lightgray,gobble=2,
                frame=lines,fontsize=\footnotesize,framesep=2mm]{python}
    ADMINS = [
        (
            os.environ.get('ADMIN_NAME', 'Admin'),
            os.environ.get('ADMIN_EMAIL', 'exampleadmin@gmail.com')
        ),
    ]
    \end{minted}

Además, deberemos hacer la correspondiente configuración del \textit{logging}. Para ello,
añadimos la variable \textbf{LOGGING} a nuestro archivo de configuración \textbf{settings.py}
y añadimos las distintas \textbf{claves}: \textbf{\textit{formatters}, \textit{filters},
\textit{handlers} y \textit{loggers}}, con sus correspondientes configuraciones. Mencionamos
la palabra clave porque dicha variable tiene formato de \textbf{diccionario}, al igual que
se usa para el \textit{logging} de Python, por lo que tendrá parejas de \textbf{clave:valor}
separadas por dos puntos (:). \\

De esta forma, los administradores podrán localizar de forma automática los errores
que se produzcan en la aplicación a través de los correos electrónicos que recibirán. Por
cuestiones de seguridad, no se va a poner un ejemplo aquí, pero en dicho correo llegaría
información completa de la petición que produjo el error, es decir, lo que produjo el
fallo y toda la configuración de la aplicación que se habría mostrado si nuestra variable
\textbf{DEBUG} de settings.py estuviera a \textbf{True}.


\subsubsection{Página de \textit{logs}}
Toda la configuración anteriormente descrita es útil solo para administradores del sistema,
pero necesitamos también que arqueólogos administradores puedan saber las acciones que se
realizan en la aplicación. Por ejemplo, imaginemos que tenemos una excavación almacenada en
la aplicación y de repente es eliminada por otro arqueólogo sin nuestro consentimiento.
Necesitaríamos saber qué arqueólogo en concreto eliminó dicha excavación, para lo que haría
falta poseer un registro de las acciones que se han realizado en la aplicación web. \\

Esto trae algunos inconvenientes a la hora de la implementación, ya que normalmente los
\textit{logs} se almacenan en archivos de texto, por lo que tendríamos que hacer visibles
dichos \textit{logs} en algún \textit{template} de la aplicación, que sería una página a la
que solo el arqueólogo administrador tendría acceso. \\

Procedamos a explicar la implementación necesaria para esta página de \textit{logs}:

    \begin{enumerate}
        \item Primero, se han registrado en las vistas todas las operaciones útiles
        relacionadas con la base de datos: añadir, modificar o eliminar registros. Para
        ello, desde la documentación de Django se recomienda crear una variable de módulo
        para el \textit{logger}:

    
    \begin{minted}[mathescape, linenos,numbersep=5pt,bgcolor=lightgray,gobble=2,
                   frame=lines,fontsize=\footnotesize,framesep=2mm]{python}
    # views.py
    import logging
    .
    .
    logger = logging.getLogger(__name__)
    \end{minted}

        Dicha variable será una instancia de la clase \textbf{logging.Logger} con la que
        registraremos todas las acciones realizadas en las vistas. En este caso, la variable
        \textbf{\_name\_} será el nombre que identificará al \textit{logger},
        proporcionando el nombre del módulo de Python donde se encuentre, en este caso
        \textbf{myFindings.views}.
        
        \item El siguiente paso, será realizar la correspondiente configuración del
        \textit{logging} en la variable \textbf{LOGGING} del archivo settings.py. Para
        ello, se han definido las siguientes partes:

            \begin{itemize}
                \item \textbf{\textit{Formatter}}: dado que necesitamos que los \textit{logs}
                sean legibles por humanos, debemos definir un formato sencillo y
                descriptivo de la acción, como puede ser el siguiente:
                \begin{center}
                    \textbf{[ Fecha, Hora ] => Usuario y acción que realiza} 
                \end{center}

                \item \textbf{\textit{Handler}}: necesitamos un manejador que almacene los
                \textit{logs} en un archivo de texto para su posterior lectura. Siguiendo
                buenas prácticas de programación, los archivos de \textit{log} nunca deben
                incluirse como código fuente de la aplicación, por lo que deberemos
                almacenarlos en un archivo que se encuentre fuera del directorio raíz de la
                aplicación y donde tengamos permisos de lectura y escritura. \\
                
                Si hacemos memoria, recordaremos que para la ejecución de nuestra
                aplicación hacemos uso de \textbf{Docker} con \textbf{Docker Compose}, por
                lo que tendremos una estructura de directorios dentro del contenedor
                disponible, donde podremos almacenar el archivo de \textit{logs}. 
                
                    \begin{figure}[H]
                        \centering
                        \includegraphics[scale=0.35]{imagenes/docker-structure.png}
                        \caption{Estructura de directorios del contenedor}
                        \label{fig:docker-structure}
                    \end{figure}
                
                Tenemos que prevenir que ante una posible caída de la aplicación los
                \textit{logs} se pierdan, por lo que estos se almacenarán en la carpeta
                \textbf{/var/log/} y el archivo que los contendrá será
                \textbf{myFindings.log}. Esta sería la ruta por defecto, aunque también
                podría modificarse a través de una variable de entorno. La configuración
                del manejador quedaría de la siguiente forma:

    
    \begin{minted}[mathescape, linenos,numbersep=5pt,bgcolor=lightgray,gobble=2,
                    frame=lines,fontsize=\footnotesize,framesep=2mm]{python}
    .
    'handlers': {
        'file': {
            'level': 'INFO',
            'class': 'logging.FileHandler',
            'filename': os.environ.get('LOG_FILE_PATH',
                                       '/var/log/myFindings.log'),
            'formatter': 'adminArchaeologists'
        },
    },
    .
    \end{minted}

                \newpage \item \textbf{\textit{Logger}}: finalmente, queda la configuración
                del \textit{logger} que recogerá los \textit{logs} que proceden desde el
                archivo views.py de la aplicación. \\

                Como hemos mencionado anterioremente, el \textit{logger} de las vistas se
                identifica con el nombre \textbf{myFindings.views}, por lo que este
                será el nombre de nuestro \textit{logger}. Además, usará el \textit{handler}
                especificado en el punto anterior y solo controlará mensajes que tengan un
                nivel de \textit{log} (\textbf{\textit{log level}}) INFO o superior. Su
                configuración quedaría de la siguiente forma:

    
    \begin{minted}[mathescape, linenos,numbersep=5pt,bgcolor=lightgray,gobble=2,
                    frame=lines,fontsize=\footnotesize,framesep=2mm]{python}
    .
    'loggers': {
        'myFindings.views': {
            'handlers': ['file'],
            'level': 'INFO',
        },
    },
    .
    \end{minted}
            \end{itemize}

        \item Finalmente, deberemos crear la ruta correspondiente para la vista de
        \textit{logs} que podrá ver un arqueólogo administrador. Para ello, definimos la
        correspondiente ruta en el archivo \textbf{urls.py}, creamos el \textit{template}
        (HTML) correspondiente que se visualizará, y la vista que manejará la petición.
        Dicha vista hará uso de la función
        \href{https://docs.python.org/3/library/functions.html#open}{open} de Python para
        abrir el archivo de \textit{logs} y procesarlo línea por línea, creando una lista
        que luego será enviada como un parámetro al \textit{template}. Un ejemplo de la
        vista de \textit{logs} es el siguiente:
        
            \begin{figure}[H]
                \centering
                \includegraphics[scale=0.20]{imagenes/logs.png}
                \caption{Página de \textit{logs}}
                \label{fig:log-template}
            \end{figure}

    \end{enumerate}

\subsection{Despliegue}
En este punto del desarrollo \textit{software}, vamos a llevar a cabo el despliegue de
nuestra aplicación web. Explicaremos cómo y por qué hemos tomado ciertas decisiones
y cómo las hemos llevado a cabo. \\

En desarrollo de \textit{software}, el término \textbf{\textit{deploy}} (desplegar o lanzar)
\cite{deploy} se define como el proceso de llevar una aplicación a producción, es decir,
hacer de alguna forma que la aplicación sea accesible para los clientes finales. Hasta el
momento, hemos trabajado con un servidor web de desarrollo \textbf{local}\footnote{Que se
ejecuta en el \textbf{entorno} de una máquina u ordenador concreto.} que Django nos ha
proporcionado con su configuración por defecto. Dicho servidor de desarrollo nos ha servido
para realizar el desarrollo completo de nuestra aplicación y realizar pruebas en un entorno
local, como puede ser nuestro ordenador. Muy resumidamente, necesitamos que nuestra
aplicación se ejecute en un entorno que no sea nuestro propio ordenador. \\

Al comienzo de nuestro desarrollo, se debatieron diversos puntos del proyecto, entre los
que se encontraba este. En un principio, se acordó con el cliente (arqueólogo administrador)
que la aplicación web estaría ejecutándose en su propio ordenador, sirviendo la aplicación
web a los distintos usuarios. Sin embargo, es fácil deducir que esta no es la mejor opción por
los siquientes motivos:

    \begin{itemize}
        \item A pesar de utilizar un entorno de ejecución aislado (usando \textbf{Docker
        con Docker Compose}), la mejor o peor ejecución del mismo dependerá de los
        \textbf{recursos hardware} que su ordenador posea.
        \item Necesitaría tener el ordenador \textbf{siempre encendido} para poder servir
        la aplicación web, afectando directamente a la disponibilidad del sitio web.
        \item Se requeriría la configuración de su propio router para permitir el acceso
        a la aplicación web desde cualquier lugar, abriendo el puerto que estuviera
        sirviendo la aplicación, normalmente el 80.
        \item No sería seguro que un usuario que no sea el administrador del sistema
        tuviese el código fuente en su propio ordenador.
    \end{itemize}

En definitiva, esta opción no es la mejor. Necesitaremos que la aplicación se ejecute en
un servidor que esté en la \textbf{nube} (en internet), y que consecuentemente esté
siempre conectado, haciendo que la disponibilidad de nuestra aplicación web sea casi
segura para los usuarios. \\

\subsubsection{Servicios en la nube}
Un \textbf{servicio en la nube} \cite{cloud-computing}, también conocido como computación
en la nube, es el uso de un conjunto de servidores que están conectados a internet
ofreciendo a los usuarios algún tipo de servicio como pueden ser servidores de bases de
datos, almacenamiento de datos, desarrollo de aplicaciones, etc. \\

Elegir el uso de un servicio en la nube tiene diversas ventajas frente a un servicio
local, entre las más importantes se encuentran:

    \begin{itemize}
        \item Se puede acceder al servicio utilizado desde cualquier lugar que posea
        \textbf{conexión a internet}.
        \item Los riesgos de \textbf{seguridad} son relativamente bajos, ya que se aplican
        diversos mecanismos para garantizarla.
        \item Normalmente, los proveedores están al corriente de las últimas
        \textbf{innovaciones} en \textit{cloud computing}, por lo que no deberemos
        preocuparnos por el uso de últimas tecnologías en el mercado o similar.
        \item No es necesario preocuparse por la \textbf{infraestructura} subyacente que
        utilice el servicio.
    \end{itemize}

Normalmente dichos servicios en la nube ofrecen planes de pago flexibles, bien según
el uso que se haga de los distintos recursos de la nube o según alguna tarifa concreta
que ofrezcan. En nuestro caso, deberemos utilizar algun servicio en la nube que cumpla
al menos los siguientes requisitos:

    \begin{itemize}
        \item Que sea un servicio \textbf{gratuito}.
        \item Que nos ofrezca una buena \textbf{integración con Django}.
        \item Que nos proporcione una \textbf{base de datos gratuita} para la aplicación.
        \item Si puede ser posible, que nos permita hacer el despliegue de la
        aplicación de una manera sencilla, como puede ser mediante el despliegue de un
        \textbf{repositorio git} o una \textbf{rama} concreta de Github. 
    \end{itemize}

Tras una larga y exhaustiva búsqueda por encontrar un servicio gratuito para el
despliegue de la aplicación, se plantearon soluciones como las que ofrecía
\href{https://docs.digitalocean.com/tutorials/app-deploy-django-app/}{DigitalOcean}
o \href{https://www.linode.com/docs/products/tools/marketplace/guides/django/}{Linode},
sin embargo, estos son de pago y, por tanto, fueron descartados.\\

Finalmente, se decidió usar Heroku \cite{heroku}, una plataforma como servicio
(\textbf{\textit{Product as a service}, PaaS}), que actualmente es una de las más
utilizadas para realizar despliegues de aplicaciones y que posee un plan gratuito.\\

Además de todas las ventajas que poseen las plataformas como servicio (no conllevan
complicaciones de infraestructura, de administración de servidores, bases de datos y
seguridad), Heroku tiene las siguientes características \cite{heroku-features}:

    \begin{itemize}
        \item Tiene un plan gratuito.
        \item Tiene \textbf{soporte para distintos lenguajes de programación}, como Python,
        Java, Ruby, Node, Go, PHP, Scala, etc.
        \item Las aplicaciones se ejecutan a través de sus propios \textbf{contenedores},
        llamados \textbf{Dynos}.
        \item Proporciona varias características de seguridad como pueden ser
        \textbf{autenticación} y \textbf{SSL} (certificado digital que autentica la
        identidad de un sitio web, habilitando una conexión cifrada con el mismo).
    \end{itemize}

Dicho esto, procedamos a explicar el proceso de despliegue de nuestra aplicación con Heroku.

\subsubsection{Django con Heroku}
En este subapartado explicaremos el proceso \cite{heroku-with-django} que hemos tenido que
realizar para poder desplegar nuestra aplicación de Django en Heroku. Para ello, lo primero
que deberemos hacer es crearnos una \href{https://id.heroku.com/login}{cuenta} en Heroku,
como en cualquier otro servicio que usemos.\\

A la hora de realizar este proceso, podemos escoger entre dos opciones, bien a través de la
\textbf{interfaz gráfica} que ofrece Heroku, o bien a través de la \textbf{interfaz de
comandos} que ofrece Heroku con la descarga de su cliente. En esta ocasión, hemos elegido usar
el cliente de comandos, ya que nos parece mucho más intuitivo y fácil de usar que la interfaz
gráfica.\\

En primer lugar, como hemos mencionado, deberemos crear una cuenta de Heroku. En segundo
lugar, descargar el cliente, \href{https://shorturl.at/emHJY} {\textbf{Heroku CLI}}
(en este caso para una distribución de Ubuntu/Debian).
        
    \begin{figure}[H]
        \centering
        \includegraphics[scale=0.47]{imagenes/heroku-cli.png}
        \caption{Heroku CLI}
        \label{fig:heroku-cli}
    \end{figure}

Una vez descargado el cliente, comprobamos que se ha instalado correctamente. Para ello,
comprobamos la versión instalada y, posteriormente, procedemos a \textbf{iniciar sesión}.

    \begin{figure}[H]
        \centering
        \includegraphics[scale=0.42]{imagenes/heroku-version-login.png}
        \caption{Login en Heroku CLI}
        \label{fig:heroku-version-login}
    \end{figure}

Tras este comando, se nos abrirá un navegador con la página de inicio de sesión de Heroku
para que introduzcamos nuestras credenciales (las de la cuenta creada previamente).\\

Una vez hayamos iniciado sesión en el cliente, el siguiente paso será crear nuestra
aplicación en Heroku. Para ello, ejecutamos el siguiente comando:

    \begin{figure}[H]
        \centering
        \includegraphics[scale=0.55]{imagenes/heroku-create.png}
        \caption{Creación de una nueva aplicación en Heroku}
        \label{fig:heroku-create}
    \end{figure}

Otro de los requisitos que estábamos buscando en el servicio en la nube era que tuviera
integración con Github, lo cuál en este se cumple: \\

    \begin{figure}[H]
        \centering
        \includegraphics[scale=0.29]{imagenes/deployment-method.png}
        \caption{Métodos de despliegue}
        \label{fig:deployment-method}
    \end{figure}

\newpage Como vemos en la imagen anterior, existen distintos métodos para hacer el
\textit{deploy}:

    \begin{itemize}
        \item \textbf{Heroku Git}: mediante un repositorio de Git subido directamente
        al proyecto.
        \item \textbf{Github}: con el despliegue de una rama concreta de un repositorio
        de Github.
        \item \textbf{Container Registry}: mediante un repositorio de Docker Hub.
    \end{itemize}

En nuestro caso, como es evidente, lo haremos \textbf{a partir de una rama} de un
repositorio de Github, concretamente del repositorio en el que venimos trabajando
para el desarrollo de todo el proyecto \textit{software}.\\

Heroku trabaja sobre el \textbf{directorio raíz} del proyecto, es decir, realiza el
despliegue trabajando sobre el directorio principal del proyecto, por lo que si no le
indicamos nada, no funcionará, ya que en el \href{https://github.com/alexespana/TFG}
{repositorio de Github} tenemos la documentación por un lado y el código fuente por
otro. Para corregir este inconveniente, deberemos agregar los siguientes
\textbf{\textit{buildpacks}} (se encargan de transformar el código que queremos desplegar
a un slug\footnote{Parte \textbf{final} de la URL que \textbf{identifica} a una
determinada página en un sitio web.}, que luego puede ser ejecutado en un contenedor, en
un \textbf{dyno}) a nuestra aplicación:

    \begin{enumerate}
        \item \href{https://elements.heroku.com/buildpacks/timanovsky/subdir-heroku-buildpack}
        {subdir-heroku-buildpack}: permite especificar un subdirectorio de trabajo
        para el proyecto.
        \item \href{https://elements.heroku.com/buildpacks/heroku/heroku-buildpack-python}
        {heroku-buildpack-python}: permite crear un entorno para aplicaciones Python,
        instalando todas las dependencias especificadas en un archivo
        \textbf{requirements.txt}.
    \end{enumerate}

Dicho esto, deberemos ejecutar los siguientes comandos:

    \begin{figure}[H]
        \centering
        \includegraphics[scale=0.39]{imagenes/first-buildpack.png}
        \caption{Paquete de construcción para subdirectorio}
        \label{fig:subdir-heroku-buildpack}
    \end{figure}

Como vemos, es necesario especificar con la opción -a el nombre de la aplicación a la que
queremos añadir los cambios. En la siguiente imagen, podemos ver cómo se especifica el
subdirectorio de trabajo para Heroku, en este caso \textbf{code/app}.

    \begin{figure}[H]
        \centering
        \includegraphics[scale=0.55]{imagenes/second-buildpack.png}
        \caption{Paquete de construcción para Python}
        \label{fig:heroku-buildpack-python}
    \end{figure}

Con estos ajustes, como podemos ver en la imagen anterior, se crea una nueva variable de
entorno, \textbf{PROJECT\_PATH}, que será tomada por Heroku al comenzar el despliegue de
la aplicación.\\

Heroku incluye funcionalidades muy interesantes como la de poder hacer despliegues
automáticos al \textbf{aplicar cambios} (\textit{push}) a una determinada rama de Github.
Por ejemplo, si creamos una rama llamada \textbf{deployment} donde hacemos todos los
cambios necesarios para el despliegue y queremos que heroku los aplique directamente al
dominio que tenemos ya funcionando, únicamente tendremos que habilitar la siguiente opción:

    \begin{figure}[H]
        \centering
        \includegraphics[scale=0.44]{imagenes/autodeploy.png}
        \caption{Automatización de despliegues}
        \label{fig:autodeploy}
    \end{figure}

Además, como vemos, nos permite realizarlos únicamente si se han pasado todos los flujos
de integración continua que posea la rama (como por ejemplo \textbf{tests}), asegurándonos
que la misma tendrá un mínimo de calidad para los clientes finales.\\

En nuestro caso, hemos creado una rama específica en Github para realizar el despliegue de
la aplicación, llamada \textbf{deployment}. Para realizar el primer despliegue de la misma,
deberemos hacerlo de \textbf{forma manual}, ya que en este caso teníamos todos los cambios
necesarios en la rama (no hacía falta volver a subir nuevos cambios, \textit{push}).\\

    \begin{figure}[H]
        \centering
        \includegraphics[scale=0.30]{imagenes/first-deploy.png}
        \caption{Primer despliegue}
        \label{fig:first-deploy}
    \end{figure}

Como vemos, el primer despliegue se ha realizado correctamente.\\


Una vez tenemos hecho el primer despliegue, tendríamos que hacernos las siguientes
preguntas: \textbf{¿qué base de datos estamos usando ahora?}, \textbf{¿cómo aplico las
migraciones para la base de datos?} En este caso, Heroku nos proporciona una base de
datos como servicio basada en PostgreSQL. Esta base de datos es la llamada
\href{https://elements.heroku.com/addons/heroku-postgresql}{\textbf{Hobby Dev}}, la única
con un plan gratuito. Procedemos a su creación mediante el siguiente comando:

    \begin{figure}[H]
        \centering
        \includegraphics[scale=0.50]{imagenes/heroku-postgresql.png}
        \caption{Heroku PostgreSQL}
        \label{fig:heroku-postgresql}
    \end{figure}

Como vemos, se nos ha creado una nueva variable de entorno llamada \textbf{DATABASE\_URL},
que deberemos indicar de alguna forma en la configuración de la base de datos de Django,
ya que antes, como bien sabemos, utilizábamos una \textbf{base de datos local} dentro del
contenedor donde se ejecutaba la aplicación. Para ello, deberemos cambiar la configuración
de la base de datos con las siguientes líneas de código:


\begin{minted}[mathescape, linenos,numbersep=5pt,bgcolor=lightgray,gobble=2,
               frame=lines,fontsize=\footnotesize,framesep=2mm]{python}
    DATABASES = {
        'default': dj_database_url.config(
            default=os.environ.get('DATABASE_URL')
        )
    }
\end{minted}

En estas líneas, indicamos la URL que tendrá la base de datos recogiendo su valor mediante
una \textbf{variable de entorno}, ya que esta fue creada automáticamente con la ejecución
del comando anterior.\\

Ahora sí podremos aplicar las migraciones necesarias para la aplicación y crear el
usuario administrador del sistema. Mediante el comando \textbf{heroku run <argumentos>},
podremos ejecutar el comando deseado dentro del contenedor en el que se ejecuta la
aplicación, que como mencionamos anteriormente recibe el nombre de \textbf{dyno}:

    \begin{figure}[H]
        \centering
        \includegraphics[scale=0.50]{imagenes/heroku-migrate.png}
        \caption{Migraciones de la BD}
        \label{fig:heroku-migrate}
    \end{figure}

    \begin{figure}[H]
        \centering
        \includegraphics[scale=0.55]{imagenes/heroku-createsuperuser.png}
        \caption{Creación de un superusuario}
        \label{fig:heroku-createsuperuser}
    \end{figure}

Con esto finalizaría el proceso de despliegue de nuestra aplicación, pudiendo acceder
ahora de forma pública a la misma a través del siguiente
\href{https://myfindings.herokuapp.com/}{enlace}.
